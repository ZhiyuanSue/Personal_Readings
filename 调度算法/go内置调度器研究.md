关于这部分，首先得说明go的协程模型MGP

# MGP模型（顺序不知道）

P（processor），M（thread），G（goroutine）

按照网上的说法是这样的

整体是一个M:N的用户态线程映射到内核态线程的工作



我的理解如下，一个go的进程，里面包含了若干个线程（M）

而最多情况下，每个物理核心上面（最多每个物理核心都有，最少不知道），都挂了一个G的队列，还有对应的runtime（相当于P），也就是说对应的P上面挂了一串G

当某个线程M被OS调度到对应的P上面去时，就去对应的P上面的G队列里面轮询并执行对应的G的任务。


除了每个P上面挂的队列里面的任务，还有一个全局的global的队列，新创建的会塞到到本地的G队列，而如果满了，就扔到全局

# 一些调度细节

如果某个M发现P的队列空了，就先去全局看看有没有，如果全局也没有，就去其他那里偷一半过来。

如果某个G因为系统调用阻塞了，也会阻塞M，系统就会先去找没抢到P的线程M，如果没有就创建一个新的M，继续从P队列上面挂着的但是没阻塞的进行调度。

如果G因为channel或者I/O和network阻塞了，那么M不会被阻塞，而是M寻找其他的可运行的G



还有一个特殊的G0

每个M都有一个G0，而全局的G0是M0的G0



自旋问题，某个M发现自己的P的队列空了，全局也空了，其他在跑的都只有一个可以用的协程（G），那他只能继续跑他自己的G0然后自旋

但是有个问题是为什么要浪费CPU，因为希望它能够当某个go协程进来之后，能够立马有个M可以跑他，但也不能全都自旋，因此设定了一个上限，超过上限就让那个M休眠。



以上是网上对这个Go的调度器的架构上的大概说明

# 在每个队列中实际使用的调度算法

对于具体的调度算法，应该是按照队列轮询的，但是对于过长的任务也可以抢占

## go的抢占式调度

### 上古版本
首先，据说go以前的栈空间有限，因此在函数调用的时候进行扩栈

因此扩栈的时候可以检查是否有抢占请求

但是不是所有运行代码都需要扩栈，所以死循环就gg了

### 当前版本

go还搞了一个sysmon线程，这个线程不会放在P里面，所以不会因为各种奇奇怪怪的原因不被调度到，而是始终都能守护

现在的机制是使用这个sysmon线程来搞事情，如果检测到某个G跑的时间太长或者很久没有GC，就发信号给M，而M本身作为一个内核线程，是能注册一个信号的，因此可以通过这种方式来进行调度。

但是go本身的调度器应该还是说，没有什么所谓的优先级等等问题。



以上是我网上能找到的资料（并且按照自己的理解写了一遍）

总而言之，深刻实践了所谓的M:N的用户态线程映射到内核态线程的工作。。。








