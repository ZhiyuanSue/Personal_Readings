bug分类

语义bug，内存bug，并发bug

表1包括了三个不同的语义错误和内存安全错误
1、崩溃不一致：文件系统如果断电或者panic之后能够恢复到正确的状态，就是崩溃一致的。
2、规范违反：就是跟POSIX不一致，这会导致比如use-after-free等问题
3、逻辑错误：与特定的文件系统紧密耦，例如F2FS实现自己的rb-tree一致性概念，但是其他文件系统中都没有，这种错误并不存在于特定的定义模式，只是悄无声息的失败，开发者其实能够意识到这些问题，并加了一大堆的检查，但是从未在生产环境中启用。
4、内存错误，在文件系统中很常见。由于在比如远程代码执行的过程中存在一大堆的影响，比如越界问题，这会影响安全性，比如KASan，KMSan，以及UBSan这些套件做的，就是用于解决越界访问，use-after-free，未初始化的读，以及未定义行为等问题。然而Hydra仍然发现了大量的内存错误。
5、其他bug：一个主要类就是并发bug，比如在数据竞争，死锁，等等

最后本文假定存储器是可靠的，就是磁盘出现位翻转，或者其他奇奇怪怪的崩溃坏道这种问题都不考虑

### 2.2
介绍相关的之前的工作
regression tests：

回归测试（确实不懂什么是回归测试）
但总而言之，这里面的回归测试，都是手工写的测试样例，是不足以涵盖这些空间的，因此，存在问题是正常的

bug-specific checkers
包括语义bug的检查，B3用于查找崩溃不一致，SiByIFS则用于查找POSIX的违反规范。
这个例子应该是说，15个操作加起来才会触发一个崩溃不一致的错误
但是对于B3则有个默认的原则就是，他的测试用例的长度不应该超过3个（好像是这么理解的吧）
而要达到给出的这个错误，B3需要很多时间来运算并且需要打破测试用例长度的限制

Formal verification
形式化验证
从理论上来说形式化验证是非常好的，但是作者说，虽然某些文件系统经历过验证，但是他们仍然有问题，包括崩溃一致性属性被破坏。

#### 本文的动机
有两个会影响bug的数量和质量的组件：
1：对于bug的定义和相应的核心检查逻辑
2：测试用例生成器和覆盖的程序状态范围

然后作者说，认为需要一个有效的explorer
通过这个explorer，在代码库中获得广泛的不变检查，检测特定文件系统的逻辑错误
改进和补充现有的bug检测器
专注于核心的bug搜索逻辑和状态探索之间的解耦

### 2.3

使用模糊测试
一些框架扩展了AFL的方法

传统的OS fuzz文件测试为了减少开关虚拟机的开销，选择复用，但是难以复现

所以作者给出了他的设计

## 3

Hydra概述

这个主要是在图6中的

他说首先是一个种子，这指的是需要挂载的文件系统以及对应的一系列系统调用的包
然后输入到input mutator中，随机改变img或者系统调用，产生一批测试用例。
然后输入到一个test case executor
然后总是从一个干净的状态开始执行，挂载给定的img，并且执行syscall
在编译目标文件系统的时候，将代码路径配置为位图。
然后收集检查器的反馈，
如果覆盖了新的位图，或者被报告为有趣的，那么被保存到种子池中，否则丢掉
如果报告了新的错误。需要放到虚拟机中进行确认

#### 3.2
文件系统的输入空间包括
1、要挂载的文件系统img
2、对挂载的img进行访问读取和写入的操作

如果要触发文件系统的错误，需要
1、挂载损坏的文件系统
2、执行一系列的操作
3、两者结合

因此，既不是只需要改变用户输入
又不是只需要改变系统调用序列
而是两者都发生改变（我的理解是，用户输入就是所谓的镜像）

Image mutation
通过突变一个系统镜像，来检查，文件系统是否足够的健壮，能够处理好存储介质的偶发错误

作者认为，将文件系统镜像视为一个黑盒，随机改变它某些位的情况，这种方法效率比较低
只需要用文件系统的元数据来随机改变并测试就够了，因为只有这部分的错误会直接影响到文件系统的稳健性，但是如果是用户的数据发生了错误，虽然用户读不出来了，但是并不会把问题扩散到整个文件系统，因此可以认为只需要考虑文件系统元数据的问题。

因此本文通过一些工具来识别找到这些元数据
然后作者随机的将这些元数据进行各种翻转啦巴啦啦的花式操作。

但是作者为了做到更好的效果，作者试图重新计算了校验和，从而不会在完整性检查的早期就被拒绝

syscall mutation


