bug分类

语义bug，内存bug，并发bug

表1包括了三个不同的语义错误和内存安全错误
1、崩溃不一致：文件系统如果断电或者panic之后能够恢复到正确的状态，就是崩溃一致的。
2、规范违反：就是跟POSIX不一致，这会导致比如use-after-free等问题
3、逻辑错误：与特定的文件系统紧密耦，例如F2FS实现自己的rb-tree一致性概念，但是其他文件系统中都没有，这种错误并不存在于特定的定义模式，只是悄无声息的失败，开发者其实能够意识到这些问题，并加了一大堆的检查，但是从未在生产环境中启用。
4、内存错误，在文件系统中很常见。由于在比如远程代码执行的过程中存在一大堆的影响，比如越界问题，这会影响安全性，比如KASan，KMSan，以及UBSan这些套件做的，就是用于解决越界访问，use-after-free，未初始化的读，以及未定义行为等问题。然而Hydra仍然发现了大量的内存错误。
5、其他bug：一个主要类就是并发bug，比如在数据竞争，死锁，等等

最后本文假定存储器是可靠的，就是磁盘出现位翻转，或者其他奇奇怪怪的崩溃坏道这种问题都不考虑

### 2.2
介绍相关的之前的工作
regression tests：

回归测试（确实不懂什么是回归测试）
但总而言之，这里面的回归测试，都是手工写的测试样例，是不足以涵盖这些空间的，因此，存在问题是正常的

bug-specific checkers
包括语义bug的检查，B3用于查找崩溃不一致，SiByIFS则用于查找POSIX的违反规范。
这个例子应该是说，15个操作加起来才会触发一个崩溃不一致的错误
但是对于B3则有个默认的原则就是，他的测试用例的长度不应该超过3个（好像是这么理解的吧）
而要达到给出的这个错误，B3需要很多时间来运算并且需要打破测试用例长度的限制

Formal verification
形式化验证
从理论上来说形式化验证是非常好的，但是作者说，虽然某些文件系统经历过验证，但是他们仍然有问题，包括崩溃一致性属性被破坏。

#### 本文的动机
有两个会影响bug的数量和质量的组件：
1：对于bug的定义和相应的核心检查逻辑
2：测试用例生成器和覆盖的程序状态范围

然后作者说，认为需要一个有效的explorer
通过这个explorer，在代码库中获得广泛的不变检查，检测特定文件系统的逻辑错误
改进和补充现有的bug检测器
专注于核心的bug搜索逻辑和状态探索之间的解耦

### 2.3

使用模糊测试
一些框架扩展了AFL的方法

传统的OS fuzz文件测试为了减少开关虚拟机的开销，选择复用，但是难以复现

所以作者给出了他的设计

## 3

Hydra概述

这个主要是在图6中的

他说首先是一个种子，这指的是需要挂载的文件系统以及对应的一系列系统调用的包
然后输入到input mutator中，随机改变img或者系统调用，产生一批测试用例。
然后输入到一个test case executor
然后总是从一个干净的状态开始执行，挂载给定的img，并且执行syscall
在编译目标文件系统的时候，将代码路径配置为位图。
然后收集检查器的反馈，
如果覆盖了新的位图，或者被报告为有趣的，那么被保存到种子池中，否则丢掉
如果报告了新的错误。需要放到虚拟机中进行确认

#### 3.2
文件系统的输入空间包括
1、要挂载的文件系统img
2、对挂载的img进行访问读取和写入的操作

如果要触发文件系统的错误，需要
1、挂载损坏的文件系统
2、执行一系列的操作
3、两者结合

因此，既不是只需要改变用户输入
又不是只需要改变系统调用序列
而是两者都发生改变（我的理解是，用户输入就是所谓的镜像）

Image mutation
通过突变一个系统镜像，来检查，文件系统是否足够的健壮，能够处理好存储介质的偶发错误

作者认为，将文件系统镜像视为一个黑盒，随机改变它某些位的情况，这种方法效率比较低
只需要用文件系统的元数据来随机改变并测试就够了，因为只有这部分的错误会直接影响到文件系统的稳健性，但是如果是用户的数据发生了错误，虽然用户读不出来了，但是并不会把问题扩散到整个文件系统，因此可以认为只需要考虑文件系统元数据的问题。

因此本文通过一些工具来识别找到这些元数据
然后作者随机的将这些元数据进行各种翻转啦巴啦啦的花式操作。

但是作者为了做到更好的效果，作者试图重新计算了校验和，从而不会在完整性检查的早期就被拒绝

syscall mutation

包括两个部分
参数突变，随机选择一个现有的系统调用并且改变他的参数
系统调用生成，随机选择一个新的系统调用，并且附加到序列的末尾

同样的，为了防止这些系统调用的参数本身是错的，被过早地拒绝掉，所以Hydra做了这么几个事情

flag对象，随机组合这些位
类似于size的整数，生成在特定范围内的，同时，试图一些敏感的参数（例如页大小或者块大小的参数）
对于buffer对象，使用一个预先生成的buffer，并填入随机的数据
对于文件描述符，维持了一个fd table，随机选择
对于paths，也维护可用的path以及过时的列表，并随机选择一个
对于其他扩展属性，随机选取可用的属性


当新生成的系统调用产生的时候，Hydra会将其附加到程序中，并且会按照这个系统调用，推测最新的状态

Exploiting the synergy
额，大概应该是说，不是同步的去变动img和系统调用，而是按照一定的顺序依次更改
他说首先是img的变异，然后如果没有有趣的用例，会调用syscall的变异，如果仍然没有有趣的调用，则附加新的系统调用

大概这么整的原因是，文件系统的操作会不断地削弱初始img遇到的一些问题

Assisting bug checkers
大概是说，会使用一些跟检查器相关的方式
比如说，如果想要测试一致性的问题，那么会在某些地方用fsync生成一个持久化的点
针对不同的测试检查，去生成不同的系统调用序列。

### 3.2
Test Case Executor

执行器有这么几个作用
当做fuzz的目标，挂载img并且执行系统调用跟踪
当做到检查器的bridge，收集结果，提供额外的反馈维度

为了支持包括内核态以及用户态（使用FUSE的）的文件系统，所以提供了两种不同的执行器
1、Library OS-based执行器
反正意思就是使用库操作系统来取代传统的操作系统，从而挂载镜像并执行用例的速度很快
2、FUSE-based执行器
这里面这种文件系统被当做独立的进程在跑
通过一个libfuse库，来调用相关系统调用

由于每次都是重新挂载并且执行，因此可以保证错误的高可重复性

### 3.4
Checker Dispatch

test case executor会调用checker dispatch
不同的检查器的接口可能会不一样
比如SiByIFS是一个独立的二进制文件
接受一个特定格式的测试用例

Hypra的检查器提供了统一的接口
并且返回一个二进制的结果：有bug或者没有bug

这里面介绍了作者团队开发的SYMC3

#### 3.4.1
SYMC3 Crash Consistency Checker
原因是，优先在内存中进行存储，只有特定时间，才需要sync等方式同步到磁盘中去，但是文件系统并不总是能做到这一点。
他的思路是这么描述的，说是，给定了初始img和syscall的trace
然后根据一致性概念，派生出一个符号表示，这个符号表示包含了所有的允许的post-crash状态，并且检查，recovered的img是否落在其中一种状态中

syscall emulation
模仿inode，除了应该写入磁盘的东西之外，还更改了提交到磁盘之前的记录属性更改的历史
这个可以看看table2
他分别做了一个in memory的记录，和一个on-disk的记录，只有在sync的之后，他俩才相同
然后存在一个长串的序列，从而，在磁盘上，应当允许的序列，只能是在模拟过程中存在的inode的序列，而in-memory的序列，不应当在恢复之后存在。
所以模拟的所有可能得结果，就是在最后按道理应该一致性落在磁盘上的结果，如果不是其中的结果之一，那么就会存在错误。
大概是这个意思

但是如果全都跟踪，那么就会太大了，所以事实上，对于已经持久化的东西，之前的更改可以被丢弃掉，因为，这就不允许恢复到以前的状态了，所以是安全的

Enumerating crash states
通过枚举生成合法的崩溃后状态集合

Check crash consistency
反正就是前面说的那样，检查是否在集合中就行了

Extending consistency semantics
原因是POSIX本身是松散的，缺少对于一致性语义的规定

其他检查插件
POSIX规范检查
逻辑检查
memory安全
（我的理解是，既然是内存中的文件系统，还是要看是否有各种内存问题）


### 3.5
Feedback Engine
反馈引擎，用于衡量测试点的新颖性
包括两种类型的反馈：
分支覆盖
检查器定义的信号，允许每个检查器注册自己的反馈格式。

### 3.6
Post-Bug Processing
对于大部分的fuzzer来说，仅仅是发现错误就停止工作了，他们认为调试信息可以解决问题，但是对于小型程序可行，不代表对于文件系统中可行，事实上，根本原因可能并不仅仅是文件系统的问题。而是操作系统其他地方出现了问题。

因此Hydra采用额外的步骤，在VM中重现每个bug，并且裁剪使用的代码，将他缩减到最小的能触发这个bug的行数

使用了Delta调试技术
尝试删除一个调用并重新测试，是否重现错误。可以通过进一步的系统蒸馏技术进一步改进

## 4
实现

选择了AFL作为fuzz工具的基础设施
选择LKL作为库操作系统
然后静态的链接到目标执行程序中

## 后面都是结果相关了，没啥值得看的了
包括了执行的速度，覆盖率，查找出多少bug，checker 反馈，崩溃一致性检查问题等等，巴拉巴拉
