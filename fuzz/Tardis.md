# Introduction

现在对于内核的fuzz这个东西，通常遵循的办法是，design paradigms of user land coverage guided fuzzers

他举了syzkaller的例子

但是包括我自己的体会，syzkaller的使用，还是需要目标内核支持一些基本的网络，进程相关的内容的，否则是没办法正常工作的
但是并不是所有的嵌入式系统都需要POSIX接口。
针对的都是GPOS

三个挑战
1、支持的平台和指令集架构，linux只支持大约10个isa上，但是uc则支持大约50多个体系结构
2、通常没有POSIX接口的标准支持
3、因为要插装，所以需要比较高效

# Tardis
tardis的设计需要看图4
在这个图中所描述，使用clang进行交叉编译，使用一个修改过的qemu来启动，并将qemu的部分内存空间暴露给fuzzer
为每个测试用例的基本块分配一个id，标记分支，然后，收集覆盖率，主机中有个对应的全局覆盖率，进行比较
这一步，分支id表，大小可以放入cache中，从而足够的高效，并且使用比如按位与的方式，进行操作并提高效率。

## A Coverage Collection
Clang支持一种通用插装机制，在每个代码块的开头都可以注入用户定义的回调，pc_trace_guard_init()函数被用于初始化整个收集过程，而pc_trace_guard()则用于在每个基本块的entry用于注入。
从而增加覆盖率。
但是，还要考虑到嵌入式系统的资源有限，需要设计一个动态的初始化机制，以及一个高效的覆盖收集回调

### 动态初始化
但是有个问题，上述的pc_trace_guard_init这些代码，本身也是需要空间来运行的，但是由于嵌入式系统，他首先是个OS，这种自动调用的函数可能未必会运行到，跟用户态是完全不一样的。那就难以提及如何运行插装了

为了能够加载这个pc_guard_init()，作者设计了一个动态初始化机制。
因为目标OS会被弄成一个ELF文件，所以可以通过符号表，在ELF符号表中，定位该函数的精确位置。

但是，通常会被弄成二进制文件，所以基于二进制版本的OS镜像，去找到对应的pc_trace_guard_init的位置。
