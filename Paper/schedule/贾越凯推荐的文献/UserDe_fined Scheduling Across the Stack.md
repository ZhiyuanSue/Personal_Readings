操作系统、网络堆栈和应用运行时的次优调度决策常常导致应用性能不佳，包括更高的延迟和更低的吞吐量。这些不良决策源于对调度器正在处理的应用程序和请求缺乏洞察力，以及各个层次之间（包括NIC、内核和应用程序）缺乏协调和协同。

Syrup是一个用户定义调度框架，允许应用程序开发人员在系统层面上表达应用程序特定的调度策略，而不必担心实现这些策略的低级系统机制。应用程序开发人员使用Syrup编写调度策略，然后在不修改其代码的情况下在系统层面上部署它们。Syrup支持多租户，可以安全地指定自定义策略。我们提供了几个使用Syrup定义应用程序和工作负载特定调度策略的示例，可以将其部署在整个系统中，并将性能提高了8倍。

本文讨论了可编程网络和调度软件的相关概念。

本文讨论了调度、可编程性和内核等关键词。

ACM Reference Format:

本文介绍了一种名为Syrup的用户定义调度系统，可以跨越整个软件栈进行调度。该系统由Kostis Kaffes、Jack Tigar Humphries、David Mazières和Christos Kozyrakis开发。

SOSP '21是一个虚拟活动，于2021年10月26日至29日在德国举行。该活动由ACM主办，共有16页论文。

1 Introduction

调度是计算机系统中的基本操作，它在多个层面上发生，从全局负载均衡器到可编程网络设备再到终端主机的操作系统。调度器执行的基本操作是将工作映射到执行资源，工作单元包括网络数据包、操作系统线程和应用程序级请求，执行资源包括NIC队列、核心和网络套接字，具体取决于调度发生的位置。

不同的应用程序需要不同的调度策略，匹配调度策略可以减少或消除一些问题，如阻塞、缺乏工作保留、优先级反转和调度器可扩展性不足。使用应用程序特定的调度策略与通用调度策略相比，性能差异通常是数量级或更多。

现有系统的调度策略通常是固定的，应用程序被迫使用默认策略，这往往是次优的。开发人员可以通过修改操作系统组件来实现自定义策略，但这非常困难，而且难以维护。因此，开发人员不应该需要成为Linux内核贡献者才能优化他们的应用程序。一些开发人员为了使用自定义调度甚至从头开始构建运行时、操作系统甚至硬件，这牺牲了与现有API、应用程序和硬件的兼容性。最近的设计提议保留现有的内核API，并使用专用硬件加速数据平面。

PAGE 2

我们认为，应用程序开发人员应该能够将其首选的调度策略表达给底层系统，而不是采用内核编程或构建专门的全栈系统来优化每个新的工作负载类别的调度。高级策略代码应该自动与现代系统中的各种调度机制集成，从而提供与应用程序特定操作系统或运行时系统可能实现的性能优势相当的一部分。

Syrup是一个用户定义调度框架，可以安全地在各个层面上定义调度策略，包括内核网络栈、内核调度器和可编程网络设备。开发者可以指定线程如何调度到核心或数据包如何调度到网络套接字。

Syrup提供了三种后端钩子：eBPF软件、eBPF硬件和ghOSt。eBPF软件用于在内核网络堆栈的各个钩子处安全地部署匹配函数，而eBPF硬件允许Syrup利用可编程网络设备。ghOSt用于将线程调度卸载到在用户空间运行的匹配函数。

Syrup是一个用于实现工作负载特定调度策略的工具，可以在几行代码中实现不同需求的调度策略，包括网络包内容识别和与用户空间代理通信等。使用Syrup可以提高多线程RocksDB工作负载的性能，同时支持多层次调度策略的部署。Syrup通过将调度视为匹配问题来简化调度策略的实现，支持多种输入和执行器类型，并提供系统钩子和Map抽象来实现不同层次的调度策略之间的通信和隔离。

2 Motivation

2.1 User-defined Scheduling Matters

本文介绍了一个简单的工作负载场景，通过设置一个处理均匀GET请求的6线程RocksDB服务器来展示调度的重要性。每个线程都绑定到相同的UDP端口，并让Linux将传入的数据报分发到套接字上。

在Linux中，使用哈希函数对数据包进行套接字分配的调度策略会导致请求丢失和高延迟，特别是在5元组和套接字数量较少的情况下。这是一个严重的问题，因为大多数云服务的SLO是以尾延迟为基础的。使用简单的轮询策略可以消除这些问题，并在比默认策略高80%的负载下实现低于200微秒的尾延迟。

PAGE 3

轮询策略对于某些工作负载更好，但并非万能。对于其他工作负载，局部性可能更重要。Linux的接收流程定向（RFS）等优化措施需要基于哈希的调度才能实现。因此，现代操作系统需要具备调度灵活性和可定制性。

现有系统缺乏调度灵活性，Linux内核仅支持六种调度策略，添加新策略需要大量开发工作。因此，应用程序开发人员通常为每个需要不同调度的应用程序类构建新的定制框架或数据平面系统。这种方法存在显著缺点。

开发新的调度策略需要大量的努力，甚至需要制作原型。

这些数据平面通常使用特殊的API，与常用的应用程序不兼容，如Linux。

专门为每个应用程序维护基础设施随着基础设施的变化变得耗时费力和昂贵。

应用开发者应该指定他们首选的调度策略，并安全地部署到现有系统中，而不是为每个应用类构建新的运行时或操作系统。系统中的调度器应该考虑应用程序的偏好，以优化特定工作负载模式。

2.2 Scheduling Requirements

本节介绍了一个重要的应用类别——键值存储（KVS），并推导出用户定义的调度框架必须满足的最小要求。KVS广泛应用于Web应用程序中，其多样化的工作负载和高性能要求提出了各种调度挑战。

不同的工作负载在不同的调度策略下表现最佳。对于具有相同执行时间的同质工作负载，最好使用低开销的先到先服务（FCFS）策略。对于执行时间变异性较高的工作负载，FCFS通常会导致头部阻塞。使用工作窃取或集中调度和抢占的策略更适合这种工作负载，可以实现高达8倍的性能提升。在极端的双峰场景中，可能需要使用大小区间任务分配策略或其变体之一来为每种请求类型保留一些核心。因此，调度框架必须允许应用程序轻松定义自定义策略。

交叉层部署：调度不仅限于单个层次的堆栈。在正确的层次实施策略可以极大地提高性能。有时，将数据包调度卸载到硬件中可以提高可扩展性，但在其他情况下，运行在软件中的更复杂的策略可以带来更好的性能。一些系统通过在堆栈的多个层次上实现协同调度策略来进一步提高性能。例如，对于高性能网络应用程序很重要的局部性约束需要在NIC RX队列和应用程序线程层面上强制执行。

现代云工作负载需要在微秒级别上运行，因此调度机制和策略应该尽可能地减少开销。应用程序的端到端延迟不能承受高于单位微秒的调度延迟。

大多数自定义数据平面和运行时系统的主要缺点是，托管多个应用程序需要启动多个专用系统实例。即使是为多路复用而构建的系统，如Shenango，也没有灵活的调度策略，对所有应用程序和工作负载混合使用相同的策略。这可能严重限制应用程序的性能，因为没有一种适合所有的调度策略。此外，任何具有内置灵活性支持的系统都需要保护措施，以确保不同的调度策略（每个应用程序一个）可以安全地共存。

3 Syrup Design

PAGE 4

Syrup is a framework that enables user-defined scheduling while meeting all of the requirements mentioned above. Application developers write a custom scheduling policy for their application using Syrup and then deploy the untrusted code safely and efficiently across system layers in the data center. Scheduling policies expressed in Syrup can move and split across layers as needed with minimal effort.

3.1 Workflow Overview

Syrup是一个调度框架，开发者可以通过实现简单的C接口来指定调度策略。应用程序调用syr_deploy_policy函数来部署策略，syrupd守护进程将策略编译成二进制文件并在用户指定的钩子上部署。应用程序和不同钩子上部署的Syrup策略可以使用类似键值存储的Map抽象通信。如果没有Syrup策略部署，应用程序将使用底层运行时和操作系统的默认调度策略。

3.2 Scheduling as a Matching Problem

Syrup是一个提供单一调度抽象的工具，可以用于不同的调度决策，并且可以方便用户实现自定义调度策略。Syrup将调度视为一个在线匹配问题，调度策略被表示为输入和处理输入的执行器之间的匹配函数。输入可以是任何支持的工作单元，执行器可以是任何系统处理组件。Syrup目前支持网络数据包、连接和线程作为输入，NIC队列、核心和网络套接字作为执行器。Syrup策略在每次有新的输入准备好进行处理时运行，例如数据包到达或线程可运行，或执行器可用。实现Syrup对其他输入（I/O操作）和执行器（NVMe队列）的支持以涵盖存储用例是简单的。

Syrup的匹配抽象提供了广泛性，可以用于从网络堆栈处理的数据包到数据中心中的作业分配等决策。在线匹配将调度分解为一系列“小”决策，提高了即使是复杂策略的可组合性和可理解性。Syrup用户可以为每个决策定义和部署不同的自包含调度策略。

Syrup实现了按应用程序在线匹配的调度，提供了可靠性和隔离性优势。每个策略只处理属于部署它的应用程序的输入，从而提高了可靠性。恶意应用程序只能通过占用一些执行器来影响整个系统性能，但这种行为很快就会被资源管理器检测和处理。Syrup如何满足这些隔离保证在§3.5和§4.3中详细讨论。

3.3 Specifying a policy in Syrup

用户只需提供一个调度匹配函数的实现，即可定义调度策略。该函数只需为传递给它的输入选择一个执行器。Syrup框架负责实际执行调度决策。这种几乎声明式的API减轻了策略开发者的编程负担。

Syrup的调度函数返回一个uint32_t类型的值，作为应用程序和钩子特定Map的键。这个Map存储可用的执行器，例如在连接调度的情况下，相应的Map存储网络套接字。用户可以根据需要填充这个Map，例如在调用bind()后添加网络套接字。还有两个特殊的返回值，PASS和DROP，分别表示使用系统的默认策略或丢弃输入。

PAGE 5

这个设计选择使得糖浆策略更具可移植性，因为它们可以在支持相同输入的层之间重复使用而无需进行任何代码更改。例如，基于哈希的策略可以将UDP数据包分配给NIC队列、核心或应用级套接字。在第5.4节中，我们展示了在糖浆中实现的这个简单策略如何将高性能键值存储应用的吞吐量提高了80%以上。

将策略转换为处理不同输入的钩子通常只需要最小限度地更改输入处理代码。我们使用两个指针来表示数据包，一个指向数据包的开头，一个指向结尾。在第5.2节中，我们提供了更多的策略示例。

3.4 Cross-layer communication

应用程序代码和不同层次的调度器之间的运行时通信对于调度性能和功能通常至关重要。例如，使用昂贵的基于学习的技术进行资源分配决策通常会被卸载到用户空间，远离关键路径。

Syrup使用Map提供键值存储API进行通信，支持用户自定义Map，可以通过文件系统权限控制访问。默认使用64位无符号整数值，支持32位无符号整数键和任意C结构体值。讨论了Map的原子性模型和不同操作的开销。

为了展示Maps和Syrup提供的灵活性，我们开发了一个类似于Reflex的基于令牌的资源分配策略。该策略定期向每个用户发放令牌，请求消耗令牌，如果用户的令牌降至零，则请求被丢弃。我们选择一个令牌生成速率，使系统略低于饱和率运行，以避免SLO违规。

这段代码用于调度UDP数据包，首先解析数据包以确定用户，然后查找该用户的可用令牌数。如果没有可用令牌，则信号系统丢弃输入。如果有可用令牌，则减少用户的令牌数并信号系统选择默认执行器。内核中的Syrup代码可以直接使用原子指令更新Map的值。用户空间中的代码可以定期为每个用户补充令牌。

地图提供了一个通用的通信抽象，可以满足不断变化的应用需求，并实现跨层通信。

3.5 Syrupd for multi-tenancy and isolation

PAGE 6

Syrupd提供了跨应用程序隔离，通过在调度钩子中加载策略之前安装检查来确保每个策略只处理属于该策略所属应用程序的输入。如果没有syrupd，应用程序也可以直接将其策略加载到不同的Syrup钩子中，但没有syrupd，就没有保护应用程序免受其他应用程序的安全措施。我们在第4.3节中讨论了syrupd如何安装输入检查。

4 Syrup Implementation

为了实现用户定义的调度，Syrup使用了eBPF和ghOSt两个框架。eBPF用于在Linux网络堆栈和可编程网卡上安全地部署策略，ghOSt用于将内核线程调度卸载到用户空间代理。Syrup的策略可以同时使用这两个框架进行部署和互操作。

4.1 eBPF & ghOSt

eBPF是一种在内核中运行用户提供代码的虚拟机，可以通过系统调用将eBPF程序加载到内核中，并在特定代码路径上触发事件。eBPF程序以字节码形式加载到虚拟机中，并在加载时编译为底层硬件指令集。eBPF支持LLVM/Clang工具链，允许用户在安全的C子集中编写调度策略，并使用“-target bpf”标志将其编译为eBPF字节码。Syrup处理部署并确保每个应用程序的策略处理正确的输入。

Syrup使用eBPF maps实现跨层通信和允许应用程序修改处理其输入的可能执行器。eBPF maps是内核数据结构，可以存储任意值并可以固定到sysfs，以便多个程序可以访问它们。Syrup使用eBPF maps来保存不同的执行器和简单的uint64_t值。BPF maps不支持同步原语，但可以直接在BPF map值上使用原子指令。缺少同步原语不会影响Syrup实现策略的能力，也不会破坏系统稳定性。

ghOSt eBPF是网络堆栈调度的优秀后端，具有安全性、低开销和灵活性。然而，eBPF对内核线程调度的支持不够成熟，因此我们选择使用ghOSt将线程调度卸载到用户空间。线程调度的粗粒度允许我们这样做，而将每个数据包的调度决策卸载到用户空间会增加太多的上下文切换开销。

ghOSt是一个新的Linux内核调度程序，实现了集中式调度，并具有易于使用的API，可实现新的集中式策略。它允许在单个用户空间线程中实现策略，类似于微内核或Exokernel。ghOSt包含一个轻量级内核调度类，可以检测有趣的调度事件，并通过消息传递API通知用户空间进程这些状态变化。用户定义的调度函数做出决策，并通过系统调用通知内核。内核通过发送中断到被重新调度的远程逻辑核心，并在这些远程核心上进行上下文切换来执行这些决策。

4.2 Supported Hooks

Syrup是一个支持网络栈和内核调度器的调度钩子的实现。它包括线程调度钩子、套接字选择钩子、CPU重定向钩子、XDP_DRV和XDP_SKB钩子以及XDP Offload钩子。这些钩子可以实现内核绕过和智能网卡的功能。

4.3 Cross-application Isolation

PAGE 7

Syrup允许同时部署多个用户定义的策略，为不同的应用程序提供以下保证。

一个应用程序只能访问属于该应用程序的输入。

应用程序加载的策略代码不能未经授权地访问其他应用程序或内核的内存。

本文介绍了 Syrup 在其 eBPF 和 ghOSt 后端中如何实现两个保证。

eBPF框架提供了内核验证器，可以在加载eBPF程序之前执行一系列检查，以确保程序不会越界访问内存。验证器模拟程序的执行过程，检查跳转和数据访问是否超出范围，并且只允许指针访问在显式检查边界违规后进行。为了满足这些要求，需要将数据包的起始和结束指针作为输入参数传递给策略。验证器还限制了循环次数，以保证程序的活性。这些eBPF特性满足了不允许未授权内存访问的要求。

eBPF最初是作为系统管理员工具设计的，开发者预期eBPF程序由root用户加载并应用于整个系统。例如，在网络堆栈的较低部分加载的BPF程序会被触发，并且可以访问每个网络数据包，而不管应用程序如何。

为了避免问题，他们提供了Syrup-as-a-service，通过syrupd长时间运行的守护进程来监听应用程序的请求。它维护一个eBPF映射，只处理属于该应用程序的输入。当守护进程接收到新的应用程序特定策略的请求时，它会将策略的BPF字节码加载到PROG_ARRAY映射中，并插入相应的端口匹配规则，以确保每个应用程序的程序仅处理其对应端口的数据包。

ghOSt实现了应用程序级别的线程调度策略保护，每个应用程序都有自己的Syrup策略，只能访问自己的内存，而不是内核、其他策略或其他应用程序的内存。每个应用程序的Syrup策略都会启动一个新的用户空间ghOSt调度进程，ghOSt内核代码确保每个Syrup线程策略只能看到属于自己应用程序的线程状态，并且只能调度自己应用程序的线程。此外，每个ghOSt策略都被隔离到自己的地址空间中，无法访问不属于自己的内存。ghOSt策略运行的优先级低于CFS，因此恶意应用程序无法接管系统。

4.4 Specifying Inputs and Executors

Syrupd和Syrup用户必须指定每个策略处理的输入和策略可以使用的执行器。执行器可以是网络套接字或硬件资源。用户可以通过向Syrup注册套接字并将其添加到相关的执行器映射中来指定网络套接字执行器。对于硬件资源执行器，Syrupd静态分配了一些资源，并将它们添加到每个策略映射中。策略可以通过返回映射中的索引来进行调度决策。

eBPF和ghOSt后端在输入方面存在差异。对于网络堆栈的上层，每个Syrup程序都与一组套接字相关联。

PAGE 8

操作系统确保每个Syrup程序处理针对该套接字集的数据报（对于UDP）或连接建立的SYN数据包（对于TCP）作为输入。syrupd在网络堆栈的较低层中执行过滤输入以正确处理策略程序的任务。策略程序接收一组指向数据包及其元数据的指针，以进行调度决策。对于ghOSt部署的策略，用户需要通过函数调用向策略注册线程并将其添加到映射中。然后，线程ID和发生的线程状态更改类型作为输入传递给调度程序。线程调度和网络堆栈策略之间存在显着差异。在线程调度中，当执行器/核心可用时，策略选择其中一个线程/输入，而网络堆栈策略在输入可用时选择执行器。

5 Evaluation

本文旨在回答以下问题：

Syrup可以用来表达和实现各种调度策略。

Syrup可以用于跨层调度。

糖浆政策是否可在不同的钩子之间移植？

Syrup的间接费用是什么？

5.1 Experimental Methodology

本文介绍了两组服务器实验设置，分别为A组和B组。A组包括两个客户端和一个服务器，每台机器都有两个Intel Xeon E5-2630 CPU，一个Intel 82599ES 10GbE NIC，运行Linux kernel 5.9。B组也包括两个客户端和一个服务器，每台机器都有两个Intel Xeon Gold 5117 CPU，一个Netronome Agilio CX 10GbE NIC，运行Linux kernel 5.9。为了避免性能变异，只使用与NIC相同插槽中的物理核心。将NIC配置为具有与应用程序使用的超线程数量相同的RX队列，并将相应的中断映射到托管应用程序线程的超线程伙伴的超线程上。

5.1.2 Applications

本文介绍了 RocksDB 数据库的特点和应用场景，以及针对 GET 和 SCAN 请求混合的负载情况下的调度挑战。作者使用 Syrup 实现了选择处理每个数据报的线程的调度策略，并使用 Syrup 实现了将 RocksDB 线程调度到核心的策略。同时，作者使用类似 mutilate 的开放式负载生成器来发送请求。

MICA是一个高性能的键值存储系统，通过将数据分区到不同的核心并利用客户端和网络接口卡的请求导向来最小化数据移动。客户端根据键的哈希值计算目标UDP端口，并将流导向规则插入到网络接口卡中，将请求导向到相应的队列和核心。然而，这种设计要求客户端了解服务器的部署细节，对于大规模部署来说是不合理的。如果客户端不知道服务器的分区细节，MICA会使用高度优化的DPDK队列在用户空间将请求导向到其“主”核心。

PAGE 9

为了在MICA中启用服务器端请求调度，我们构建了一个基于AF_XDP的后端。AF_XDP是一种地址族和套接字类型，它允许内核直接将传入的数据包重定向到用户空间内存缓冲区，避免了昂贵的协议处理。AF_XDP套接字可以根据网卡和内核版本支持两种操作模式。在本机模式下，数据包在缓冲描述符的DMA之后和SKB分配之前就被转发到用户空间，这需要驱动程序的支持，但可以实现零拷贝网络。在通用模式下，数据包在netif_receive_skb()函数分配SKB之后被转发。这种模式与驱动程序无关，但不支持零拷贝。

使用AF_XDP套接字时，可以使用Syrup在两个层面上进行调度，即选择一个NIC RX队列和选择绑定到每个队列的AF_XDP套接字。在MICA实验中，使用8个MICA服务器线程和原始MICA论文中的负载生成器，配置使用AF_XDP后端。

5.2 Scheduling policies in Syrup

本文旨在展示Syrup可以轻松用于定义和实现各种调度策略，以提高工作负载性能。通过使用一个类似于Shinjuku的RocksDB部署，我们证明了Vanilla Linux策略在高负载下存在性能问题。Syrup可以解决这个问题，提高工作负载性能。

为了避免不平衡，我们使用Syrup在不到10行代码的情况下实现了一个简单的轮询策略。这个策略也适用于图2中的仅GET的工作负载。在我们的策略中，我们初始化一个索引并在每次调度数据报时递增它。非原子递增可能会导致良性竞争条件，例如将两个连续的数据报调度到同一个套接字，但这不会影响策略的性能。然后，我们使用索引选择一个套接字/线程，确保完美的负载均衡。在我们的情况下，NUM_THREADS是一个编译时参数，但也可以在运行时从Map中动态读取。图6显示，Syrup定义的轮询策略消除了噪音，并在尾延迟爆发之前实现了比Vanilla Linux策略高124%的吞吐量。

本文介绍了一种名为Syrup的系统，它可以通过SCAN避免策略来减少尾延迟。SCAN避免策略包括用户空间和内核组件，通过随机选择网络套接字来避免长时间的SCAN请求阻塞短请求。使用该策略，可以将99％的延迟保持在150微秒以下，比Vanilla Linux的延迟低8倍。在更高的负载下，尾延迟逐渐增加，因为所有套接字都在处理SCAN请求，很难避免头阻塞。

研究者使用Syrup开发了一种基于SITA策略的第三个策略，该策略可以查看数据包内容并做出更明智的调度决策。他们在Syrup中实现了一个简单版本的SITA策略，该策略首先使用指针算术进行边界检查，然后检查每个数据包的请求类型。如果请求是SCAN，则将其发送到网络套接字0；如果请求是GET，则在其余的网络套接字之间进行轮询。Syrup的SITA策略可以在高负载下保持尾延迟低，并且与Shinjuku等内核绕过系统的性能相当。

Syrup可以快速实现各种调度策略，包括跨层或查看输入的策略，只需少量代码（约10行）即可大大提高应用程序性能（高达8倍）。

PAGE 10

本文介绍了一种更复杂的基于令牌的调度策略，用于处理高优先级的低延迟敏感流量和低优先级的最佳效果流量。该策略每100微秒生成一个令牌，高优先级用户使用令牌，剩余的令牌则赠送给低优先级用户。令牌生成速率为每秒350,000个，可以保证在6核设置中不会出现尾延迟爆炸。

实验中，总负载保持在400K RPS，扫描不同的LS和BE负载组合。当LS负载较低时，BE用户可以利用多余的令牌服务大部分负载。将令牌捐赠给BE用户不会影响LS用户的性能，直到她的负载达到350K RPS的饱和点。如果使用循环策略，BE用户的吞吐量略高，但LS用户的尾延迟高达6倍。

Syrup可以用于在整个堆栈中强制执行应用程序特定的服务质量（QoS）保证。

5.3 Cross-layer scheduling using Syrup

Syrup的主要贡献是实现了协调的跨层调度，可以用于实现RocksDB工作负载的调度策略。该策略将可运行的线程与逻辑核心匹配，并使用ghOSt进行部署。该策略优先处理GET请求的线程，随时抢占处理SCAN请求的线程。同时，在套接字选择层使用SCAN Avoid策略进行请求/数据报调度，无需为每种请求类型静态保留线程。值得注意的是，在线程调度活动时，只有五个核心可用于应用程序处理，一个核心保留用于旋转的ghOSt代理。

PAGE 11

本文介绍了Syrup调度策略的性能表现。单独使用线程调度或SCAN避免策略时，GET请求的尾延迟很高，SCAN请求的吞吐量也会受到影响。但是，将两种策略结合使用可以避免阻塞和延迟，提高请求的性能表现。同时，线程和请求调度的结合可以避免在同一核或网络套接字中排队多个SCAN请求，但是线程调度会占用一个核心，略微降低了SCAN请求的吞吐量。

Syrup可以轻松实现跨层级的策略，并相互通信，最大化性能。

5.4 Syrup using different hooks

MICA调度的主要目标是优化局部性。使用Syrup，我们可以在MICA的网络堆栈中的多个钩子中部署自定义调度策略。在内核AF_XDP钩子中使用eBPF部署的策略，我们称之为Syrup SW，从每个传入数据包中读取键哈希，并使用简单的模运算选择数据包的“主”线程的相应AF_XDP套接字。在这种情况下，每个MICA线程创建8个AF_XDP套接字，每个套接字对应一个NIC RX队列。同样的策略在第二个钩子中被重用，这次在Netronome NIC上运行的Syrup HW中选择一个RX队列。对于这种情况，每个MICA线程只创建一个绑定到NIC RX队列的AF_XDP套接字。调度代码与第3.3节中讨论的简单基于哈希的示例非常相似。

本文介绍了两种不同的MICA工作负载，一种是50% GET和50% PUT操作，另一种是95% GET和5% PUT操作。使用应用层数据包重定向的原始MICA版本的尾延迟在1.7-1.8 MRPS的负载下超过1ms。使用Syrup进行AF_XDP层调度的MICA版本在2.7-2.8 MRPS的负载下超过了这个阈值。使用Syrup HW的尾延迟在3.2-3.3 MRPS的负载下爆炸，比Syrup SW变体高出18%，比不使用Syrup的版本高出83%。Syrup HW消除了所有主机数据移动，因为数据包直接被引导到最终处理它们的MICA核的超线程伙伴。

使用可编程的Netronome NIC时，三种变体的尾延迟相对较高，吞吐量相对较低，因为它不支持零拷贝。但是，当我们在支持零拷贝XDP_DRV钩子的非可编程Intel 82599 NIC中尝试我们的AF_XDP后端（Syrup SW）时，使用相同数量的NIC时，我们实现了与MICA论文中相似的延迟和吞吐量。

PAGE 12

Syrup编写的策略具有可移植性，因为它们可以根据底层操作系统和硬件的能力在不同的层次上部署。

5.5 Syrup ’s Overheads

Syrup调度策略的开销主要有两个来源。第一个是用于制定和执行调度决策的CPU周期。所有策略都是用很少的代码实现的，运行时间都在2000个周期以内。这表明Syrup可以用于低延迟和高性能的工作负载。各种策略之间的差异很小，因为大部分时间都花在了执行调度决策上。

Syrup的第二个主要开销是在不同层之间传递信息所需的时间，即从Map中读取和写入信息。根据表3显示，对于不同后端发出的不同Map操作，访问基于主机的Map（Host-based Map）需要大约1微秒的时间，无论是否存在争用（两个线程同时发出操作）和操作类型。而访问基于Netronome NIC（Offload）的Map需要大约25微秒的时间。我们预计随着采用新的更快的I/O标准（如CXL [8]），对离线映射的访问成本将会降低。从内核或NIC硬件中运行的Syrup代码对映射的访问成本与常规内存访问相同。用户空间应用程序可以将eBPF映射进行内存映射，并直接使用常规内存操作进行访问。然而，这个功能只在较新的内核中可用，因此与ghOSt不兼容，并且我们在实验中没有使用它。

6 Discussion

6.1 Adding more backends

最近的研究表明，改进IO请求调度可以显著提高性能。Syrup的调度模型可以自然地扩展到存储，可以使用Syrup将IO请求与存储设备队列匹配。事实上，我们在第5.2节中评估的基于令牌的策略与Reflex在闪存设备中用于IO请求调度的策略非常相似。

Syrup目前主要关注终端主机调度，但调度发生在数据中心堆栈中，从集群管理器和软件负载均衡器到可编程交换机。可以扩展Syrup以支持这些后端，因为它们与Syrup的调度匹配视图完全兼容。开发人员将在C代码中实现其首选调度，该代码将在用户空间中运行，或者在可编程网络设备中运行的P4代码中实现，Syrup框架将安全高效地部署该代码在整个数据中心堆栈中。新的硬件设备要与Syrup配合良好，需要三个东西：可编程性，输入和执行器之间的匹配抽象，以及支持Map抽象的支持，该抽象可以驻留在设备，终端主机或远程。

将Syrup扩展到分布式环境需要解决一些有趣的研究挑战，包括确保Map抽象仍然有效，保证用户定义的P4程序之间的隔离，可以通过插入P4匹配/操作规则来实现。可能的解决方案包括采用管理的键值存储服务或使用分区系统。

6.2 Making coding in Syrup easier

Syrup使用的安全C子集提供了一种自然的方式来编写和安全地注入调度函数，但有时使用起来很麻烦。开发人员需要在引用可能不安全的内存访问之前显式检查。将这些检查自动添加到Syrup中是一个自然的下一步。

为了避免代码碎片化，可以采用P4作为Syrup的主要调度语言。但是，考虑到P4的匹配/动作模型有限，有必要探索是否可以将类似于Lucid的高级语言编译成低级eBPF和P4代码，甚至开发一个定制的领域特定语言来进行调度。

6.3 Support for Late Binding

PAGE 13

Syrup在Linux的网络堆栈中使用的大多数钩子只支持将输入提前绑定到执行器。换句话说，数据包的到达会触发一个调度函数，在那时必须选择一个执行器。尽管提前绑定很方便，因为它不需要调度器端的排队，但当具有较短处理时间的输入被卡在同一个执行器中具有较长处理时间的输入后面时，可能会导致头部阻塞。通过使用后期绑定可以避免这个问题。当使用后期绑定时，只有当执行器可以立即开始处理输入时，才将输入分配给执行器。在Linux网络堆栈中实现后期绑定需要将数据包存储在临时缓冲区中，并在执行器发出信号可用时触发调度函数，例如当线程在套接字上调用recvmsg时。

6.4 Scheduling Streams

对于通过流发送的调度请求尤其具有挑战性。可以使用Linux机制KCM来支持TCP流发送的请求级调度。对于UDP的多数据包请求，用户可以将请求映射到执行器的Map中。最近开发的网络协议和RPC框架都是基于请求的。

7 Related Work

本文介绍了跨层调度的相关工作，包括早期调度、利用NIC高级特性、集中式调度、基于令牌的策略、硬件线程调度等。Syrup可以方便地开发和部署这些策略，而无需为每个策略实现一个新系统。

用户可以向内核传递应用程序特定的信息，内核也可以向用户传递信息。这种方法早在90年代就已经存在了。Redline和MittOS是两个使用这种方法的例子。Redline可以让交互式应用程序声明规范，内核的资源管理器可以使用这些规范来确保响应性。MittOS允许应用程序向内核传递截止日期信息，以便快速拒绝无法满足截止日期的请求。

Syrup是一个系统，可以让应用程序安全地控制传统由内核处理的功能。它利用eBPF框架，安全地将代码注入到Linux内核中，并通过通用映射抽象实现用户空间和内核空间之间的任意信息交换。Syrup的设计灵感来自于Exokernel、Infokernel和Caladan等系统。

eBPF是一个新的内核特性，已经被广泛应用于云防御和负载均衡。Cilium公司基于eBPF构建了网络、可观测性和安全平台。Facebook的Katran是一个C++库和BPF程序，用于构建高性能的L4负载均衡转发平面。与Syrup不同，Katran只支持单个调度决策，并且不允许不同的应用程序在同一台服务器上安全地指定和运行自己的策略。

最近，学术项目开始使用eBPF进行更多的奇特应用。BMC利用eBPF创建内核中的memcached缓存，实现了比内核旁路技术更高的效率和性能。Prism使用eBPF和连接交接协议来实现对象存储系统的高效代理。Wu等人也在使用eBPF进行研究。

PAGE 14

本文探讨了使用eBPF技术进行存储的潜在用途，同时指出了其中的挑战和机遇。

8 Conclusion

Syrup是一个用户定义调度框架，可以安全、高效地在整个堆栈中以高级方式指定调度策略，将调度视为工作单元和执行器之间的匹配问题，无需开发人员处理低级细节和系统机制。应用程序可以使用Syrup在几行代码中实现以前需要数月开发工作才能实现的性能提升。

Acknowledgments

感谢Peter Kraft、Qian Li、John Ousterhout、Deepti Raghavan、Amin Vahdat、Thomas Wenisch、Eric Brewer、我们的Shepherd Ryan Stutsman和匿名的SOSP审稿人的有益反馈。这项工作部分得到了斯坦福平台实验室赞助和Facebook的支持。
