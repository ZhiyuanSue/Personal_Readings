# 摘要

大概就是评价了一下API使用频率

安装Ubuntu需要224个syscall，208个ioctl，fcntl（用于修改文件的）

但有些就很少用到，

除此之外，还有一些安全相关的API，还用新的API取代了，取代了也就算了，关键是新的API，他适配比较慢。。。虽然软件领域很正常，但是确实听了挺无语

# Introduction

OS开发者试图找到哪些API是重要的

另外，弃用一些API的影响是很难评估的，因为缺少一些指标，通常需要一个漫长的过程，用户会反复收到警告，而且仍然有可能破坏某些应用程序

例如一直要从signal系统调用转向更安全的sigaction系统调用，但是因为32位x86的Linux还在用他所以一直没有删掉。



另一方面，对于新实现一个OS，通常会弄一个Unix或者Linux兼容层，仅仅支持一小部分的syscall，但是哪些API需要支持，也没有一个确切的标准。



本文查找了3w多个packages，并且每个package记录了他们的使用频率。

所以他搞了个事情，说把哪些API删了，或者说找个最小的API集合（感觉是这个意思）能够支持的最多



本文的贡献主要包括以下几个方面：

- 提供了某种衡量这个东西的一个方法（就是前面找的说找最小API集合情况下，看看能够支持的最多的软件）

- 对Ubuntu15.04的API的分析

- 对于API使用模式的一个分析，对用的不多的API的使用率的快速下降的长尾分布

# Some APIs Are More Equal Than Others

安装和软件是两回事

安装用的是Ubuntu和Debian的安装。

以及用的软件包支持的API和软件包的流行程度

举了几个例子，但我觉得不重要

首先这里讨论的API用的是一个软件包所有可以用到的API

包括直接调用的，或者是通过一些共享库来进行使用的API

（但是我，读者，认为，除了需要考虑软件包使用哪些API，以及该软件包流行的程度，需要考虑的应该还有包括在每个软件包中，用户调用各种功能的API的频率的不同，因此我认为这个东西应当也考虑进去，比如我使用LS命令，有些奇奇怪怪的选项我从来不用，那不用某些API是非常正常的，因此我认为这是一个需要补充的。）



# API Importance

定义了一个API Importance，大概就是说，每个安装都必然用到的API，其目的就是说，假设有些安装包，每次安装都必须要，但是哪怕某个API只是这个安装包用一次，其他安装包再也不用了，但这个API仍然是非常重要的。



# Weighted Completeness

用来衡量一个新的OS的实现，需要准备哪些API就好

从目标系统支持的API列表开始，根据包的API足迹，生成支持和不支持的包的列表

然后考虑依赖性，如果受支持的包依赖于不受支持的包，则两个包都被标记为不受支持

最后，根据这些软件包安装统计数据去评价支持的软件包列表，计算出一个加权结果



# 数据收集和静态分析的比较

使用了一个静态二进制分析来分析syscall用了哪些。

优点是有利于不必要的那些源代码或者测例。

如果使用strace等工具会导致过于依赖于输入（哦，看来作者还是比较考虑周到的，但是还是我前面的问题，这些软件的包，额，就是他每个API也有个使用频率的问题，

为了缓解软件包故意混淆自己的问题，抽查静态分析是否为strace结果的超集

只考虑ELF文件



# 限制约束

只考虑开源的软件，但是如果是有商业的软件，不作考虑

他也确实提到了，不考虑实际使用频率，只考虑安装频率，也没有足够的历史数据来比较API使用情况变化（这也是我前面主要关注的点）

还考虑到了，如果有些编译时就考虑到了定义了Linux宏来进行Linux下的预编译的情况，那么会导致很多API的使用频率发生变化

其他巴拉巴拉一堆实际工作的缺点，既然作者已经考虑到了这些问题，我也懒得吹毛求疵。



# 关于Modern LinuxAPI的使用率

发现远远不止300个调用，还有包括ioctl等等对向量的一些使用

## 试图回答几个问题

1. 实现一个新的系统的时候需要哪些syscall，或者说取代他们需要更大的代价

2. 哪些syscall有可能因为用的太少而被取代

3. 哪些syscall在OS没有实现的时候，应用程序仍然想要试图实现。

Linux3.19总共有320个syscall，其中前224个必须被实现，而224-257则重要度逐渐下降，到257之后，基本重要性也就在10%以下了



## 还考虑了libc这样的库的情况。

只有若干个API被库所用到，很多API使用率都在10%以下。所以其实也可以裁剪库？？？



对于44个使用率在0-10的syscall，举了个例子，就是POSIX和systemV的消息队列，可以互相替换，POSIX用的少。

列举了一些只被一两个包用的API。



还有18个，完全没用到。

但是吧，像restart这种syscall，他虽然没人用到，但是kernel自己用了（乐）



## 回答一个如何从无到有构建一个原型系统的情况。

需要约40个syscall才能起码跑个helloworld，145个才弄完50%，202个是90%，大概快250才七七八八基本都支持。QEMU的MIPS模拟器需要270个syscall。



## 另外，没必要在设计早期支持ioctl，fcntl和prctl的每个操作。



对于Vector的系统调用支持，相当于一个扩展，其中52个也是需要100%实现的。而fcntl和prctl，前者11/18需要实现，后者9/44需要实现。也基本都是前面需要100%实现，而后面快速下降的拖尾分布。

因此，除了224个左右的必须的原型系统API，这些ioctl，fcntl和prctl都是需要实现的。



ioctl有着更长的未使用操作的拖尾。



## 关于Pseudo-File和Devices

还通过一个虚拟文件系统，比如proc，dev等等对于system的一个文件系统化，提供了一些操作。

说到这种API形式的一些检查限制

只有前7个是100%用到的，前12个看上去比较重要，什么/dev/null这种，后面的基本上无了。

顺带引申出一个权限问题，因为这是通过文件系统访问的，所以files的操作权限是需要特别注意的



## 关于Library接口

只有42.8%是必须的，50.6%低于50%，39.7%的低于1%。

想要拆分成多个子库来提升。

一方面是代码重用攻击，另一方面过长的重定位条目会导致只有前几页的重定位表被加载了，剩下的都延迟加载了。



# Linux系统和仿真层

作者做了4个Linux兼容的操作系统

User-Mode-Linux

L4Linux

FreeBSD

Graphene 库操作系统

前两个是用的Linux的系统调用表

后面俩则是用自己的并且不支持的就重定向到不支持。



前俩那个加权完整性都是90%往上了，有280个系统调用，而FreeBSD则62.3%

但是最后一个就离谱了，只有不到1%。



## 对于libc的评估

还评估了几个libc的变体 eblibc，uClibc，musl，dietlibc和GNULibc的兼容性。只有eglibc和GNUC完全兼容，musl和UClibc完整性低。dietlibc就是个渣渣。



# 不加权重情况下的API

原因是一个包可能无处不在导致其给API加权太多，这段去除这个影响。

还要考虑安全API的变体，看看仍有多少不安全的API被使用导致的受到攻击。

这回就不一样了，只有40个系统调用是必须的，130个是10%以上的。



大量的软件包仍然使用较旧的系统调用



还有就是，大多数开发人员更喜欢可移植或者通用的API而不是Linux特定的API。除了pipe2之外，其他的特定的Linux API都低于10%



剩下几个章节，我觉得不必要看，对于系统开发人员的影响，实现细节（我感觉我只想要之前的结论）

相关工作（也就是文献综述，有需要再抄吧）



# 结论

首先需要额外考虑文件操作，以及ioctl什么的

会超过320个系统调用，其他，上面写了。没啥用。
