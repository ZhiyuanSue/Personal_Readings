用敏捷方法开发高性能RISC-V处理器

PAGE 1

徐楠∗ †， 于子豪 ∗， 唐丹 ∗ ‡ ， 陈国凯 ∗ †， 陈璐∗ †， 苟瑞∗ †， 玥金∗ †， 李千若 ∗ †， 李昕∗ † ， 左中国∗ †， 林佳伟∗ †， 刘彤∗， 刘志刚 ∗， 谭家展 ∗， 王华强∗ †， 王慧哲 ∗ †， 王凯帆∗ †， 张传琦 ∗ †， 张发旺， 张林娟 ∗ † ， 张子飞 ∗ †， 赵阳阳 ∗， 周耀阳 ∗ † ， 周一珂 ∗， 邹江瑞， 蔡烨， 欢丹丹 ¶ 李祖松 ， 赵七月¶ ， 陈子豪 § ， 何伟 §， 全启元 §， 刘兴武 ∗ ∗， Sa Wang ∗ †， Kan Shi ∗， Ninghui Sun ∗ † and Yungang Bao ∗ † ∗ 中国科学院计算技术研究所处理器国家重点实验室 † 中国科学院大学 ‡ 北京开源塞浦路斯研究院，中国 § 中国鹏程实验室 Beijing VCore Technology Co.， Ltd.， 中国 深圳大学，中国 ∗ ∗ 大连理工大学

摘要-虽然研究表明敏捷芯片设计方法有望以更有效的方式维持计算性能的扩展，但由于缺乏支持敏捷芯片设计的工具链和开发框架，特别是对于大型现代处理器，它在实际应用中的应用仍然有限。2)传统的验证方法不够敏捷，成为整个过程的主要瓶颈。为了解决这两个问题，我们提出了minjie，一个支持敏捷处理器开发流程的开源平台。minjie集成了一套广泛的工具，用于逻辑设计，功能验证，性能建模，预硅验证和调试，以提高最先进处理器设计的开发效率。我们通过使用敏捷方法构建两代开源超标量外购RISC-V处理器(代码为XIANG SHAN)来演示MIN JIE的使用和有效性。我们使用SPEC CPU2006基准来量化香山的性能，并证明香山达到了具有行业竞争力的性能。 Keywords-agile发展;开源硬件;微体系结构;

我的介绍。

在数据驱动的世界中，芯片架构师在设计高性能处理器时需要仔细平衡传统的设计指标，如性能、功耗和面积(PPA)，以及各种指标，如上市时间和有限的预算。这需要新颖的方法和工具流来监督和促进整个过程。 在过去的几年中，敏捷芯片设计方法引起了学术界和工业界的关注，因为这些方法可以潜在地限制庞大的工程成本，减少芯片开发的长设计周期，同时保持合理的PPA规格。越来越多的研究证明了敏捷方法在设计CPU内核[4][5][6]、片上系统[7][8]和硬件加速器[9][10]中的使用。此外，还提出了多个敏捷开发框架[7]b[11][12][13]，以支持快速芯片设计、仿真和测试。 尽管有这些好处，但敏捷设计方法的使用仍然有限，特别是在实用的现代设计中。为了进一步调查这个问题，我们采访了来自12家超大规模芯片制造商和主要芯片公司的芯片架构师、研究科学家和首席工程师，这些公司涉及多个领域，包括数据中心、智能手机、通信和汽车。根据这项调查，我们总结了关于敏捷方法的两个常见问题: 1)敏捷方法还没有完全准备好处理复杂的问题 处理器。尽管许多芯片已经建成使用 敏捷方法，大多数都是研究原型和 都是相对较小或不太复杂的设计[1][14]b[15]。 目前尚不清楚是否可以直接采用类似的方法 到大型设计，如现代处理器。 2)验证过程仍然不够敏捷。而 现代验证方法，如UVM [16]， 约束随机[17][18]和形式方法[19][20] 是否广泛采用，以加速过程的验证 是否仍是整个芯片发展的一大瓶颈 工艺，特别是大型设计bb[22][23]。现有的 敏捷开发框架更多地关注快速 原型而不是验证。因此更多的工具 都需要支持整个敏捷工作流程。

在本文中，我们的目标是解决这两个问题。针对第一个问题，我们提出了一个集成了丰富的敏捷开发工具的平台，用于逻辑设计，功能验证，性能建模，芯片验证和调试，以进一步提高最先进处理器设计的开发效率。为了演示该平台的使用和功能，我们开发了高性能超标量无序RISC-V处理器“翔山”。在闵杰的支持下，我们用了十个月的时间完成了第一代香山。翔山于2021年7月在28nm CMOS工艺上以1.3GHz的频率进行测试，在SPEC CPU2006上使用1GHz的真实芯片测试，达到7.01。然后，我们以敏捷的方式优化了第二代产品，计划在2022年第四季度在14nm CMOS工艺上以2GHz的速度完成。实验结果表明，采用rtl仿真平台上具有代表性的程序片段，第二代在SPEC CPU2006上实现了10.06/GHz的归一化分数。 针对第二个问题，我们进一步研究了验证工作流程的瓶颈，并通过提出敏捷工具和一种新的基于diffi - rule的敏捷验证(DRAV)机制来增强传统的验证方法，这些方法共同构成了开发平台MIN JIE。

PAGE 2

1)为了减少验证开销，DRAV将测试结果的严格等价放宽为检查特定的困难规则，在被测设计(DUTs)和参考模型(REF)之间形成n -1对应关系。关键的见解是，在不同的微架构下，不同的结果可能在设计规范下是合法的。DRAV将架构行为抽象为困难规则。它们是根据规范定义的，这些规范在不同的处理器设计中具有确定性和持久性。因此，同一设计规范下的不同设计可以用同一套判据进行验证。 2)为了识别RISC-V处理器行为不确定性的来源，明确RISC-V处理器的差异规则，我们提出了一个由差异规则检查器和信息探针组成的验证框架DiffTest。关键的洞察力是将信息探针嵌入到高级HDL(例如，Chisel)设计中，并使用它们将信息传递给差分规则检查器。 3)为了解决rtl仿真中调试信息带来的关键性能开销，我们提出了一种轻量级仿真快照技术(LightSSS)，用于在正常模式和调试模式之间按需转换。LightSSS通过只存储与写时复制机制不同的数据来有效地创建电路无关的快照。 本文做了以下贡献。

•支持敏捷处理器开发流程的minjie平台，为高性能处理器等大规模数字电路设计提供逻辑设计、验证、验证、性能建模和调试等新开发工具。 •我们采用敏捷提供的敏捷方法，构建了两代代号为翔山的标量无序RISC-V处理器，具有行业竞争力。 •MIN JIE和XIANG SHAN都是开源的，以促进未来使用敏捷方法进行微架构和系统级设计的研究。

2背景A.敏捷和开源硬件

在过去的几年里，敏捷芯片开发和开源硬件获得了越来越多的关注。敏捷和开放方法的目标是降低芯片开发的显著工程成本和较长的设计周期。例如，Lee等人采用敏捷开发方法构建了11个RISC-V微处理器，这些微处理器在五年内被贴在28纳米和45纳米CMOS工艺上。利用开源硬件设计工具，5名本科生[14]b[24]能够在4个月内设计出一个110纳米的linux兼容RISC-V处理器。

然而，由于缺乏使用敏捷开发工具的高质量硬件项目，敏捷和开放方法在高性能和复杂设计方面仍未得到认可。BOOM[6]和XT910[25]是两个性能最高的开源RISC-V处理器，但它们的性能仍然落后于商用x86和ARM处理器。此外，这些处理器的开发和验证工作并未完全向公众披露。因此，敏捷芯片开发的能力还没有得到充分的证明来说服业界，这阻碍了敏捷方法的广泛采用。

B.处理器功能验证

处理器验证的常见做法是建立一个联合仿真框架，以比较测试设计(DUT)和参考模型(REF)结果之间的等价性，如图1所示。结果可以根据验证目标配置各种内容。例如，为了确保isa级别的遵从性，结果被定义为处理器的体系结构状态，例如通用寄存器和程序计数器。底层框架将DUT的结果与指令集模拟器(ISS)的结果进行比较，后者是目标ISA的黄金模型。 然而，这种严格的等效测试策略必须解决受设计的微体系结构实现细节影响的不确定性行为的问题。

PAGE 3

例如，不精确的异常[26]和异步中断[27]可能会不可预知地中断处理器的正常指令流。最先进的联合仿真框架Dromajo通过强制REF采用与DUT[27]相同的中断来瞄准确定性架构状态。然而，对于没有微架构信息的参考模型，存在更多的非确定性场景，这些事件通常会导致DUT和REF的结果出现分歧。这也是形式验证和软件测试[28][29][30]中被广泛接受的挑战，需要维护和探索一个大的状态空间。在第三- a节中，我们演示了在联合模拟环境中解决这一不确定性问题。

C.验证框架

图1(a)说明了传统的设计和验证交互。给定相同的设计规范，RTL工程师用Verilog构建处理器，而验证工程师则用其他语言(例如SystemVerilog, C/ c++)为处理器的各个部件和级别开发相应的参考模型。Verilog设计(DUT)和REF被放入验证框架(如UVM)中，以检查其结果之间的等价性。 传统的验证侧重于特定的设计实例，而敏捷开发鼓励维护生成器。如图1(b)所示，敏捷设计的出现涉及频繁生成更新设计实例的高级hdl。这种新的设计范式在参考模型的建立及其与DUT的交互方面带来了两个挑战。首先，REF需要在REF的不同迭代中涵盖不同的微体系结构相关细节，并避免它们的结果之间的不匹配。其次，对高级hdl的微小修改可能导致Verilog发生重大变化，从而严重破坏原始验证码。因此，验证工程师受到敏捷开发的影响。我们在第III-B节中讨论了这两个问题。

D. rtl仿真与调试

硬件设计需要经过长时间的rtl仿真验证过程。常见的方法包括基于软件、FPGA和模拟器的rtl仿真。 FPGA运行速度最快(数十MHz)，对于硬件原型设计非常重要。虽然许多工作已经解决了可扩展性[31][32][33]、可调试性[34][35][36][37][38]和长合成时间[39]等问题，但fpga仍然需要改进以适应大规模设计[40][41][42]。 Cadence Palladium[43]、Mentor Veloce[44]和Synopsys Zebu[45]等模拟器可以以MHz的速度模拟大型电路，具有完全可见性和良好的可调试性。然而，它们非常昂贵，因此难以在学术界和工业界大规模部署。

基于软件的rtl模拟器[46][47]是最常用的工具，并提供模拟电路的完全可见性。但是，对于大规模设计，软件方法以KHz的速度运行，并且在启用必要的调试信息(如波形和日志)时变得更慢(在我们的XIANG SHAN案例中，性能降低了12倍)。由于基于软件的rtl模拟器几乎被用于所有的硬件项目，因此解决其调试效率问题具有重要意义。第III-C节演示了加快调试过程的方法。

E.绩效评估

准确的预硅性能评估和验证对于高性能处理器非常重要。用敏捷方法评估处理器设计也是至关重要的，因为它会影响特征探索的效率。特征挖掘和性能评价的方法多种多样。 建筑模拟器[48][49]因其运行速度快、编程简单等特点，被广泛用于设计空间探索和性能评估。然而，GEM5的开源版本的性能和架构与最先进的高性能处理器之间存在巨大差距。根据我们的实验，大致香山参数对准的GEM5模型在2GHz时在SPEC CPU2006上达到~ 7/GHz，比香山低~ 30%，比苹果M1[50]低~ 70%。为了获得更好的准确性，公司必须为体系结构模拟器维护独立的团队，以与真实RTL模型的微体系结构保持一致，这需要大量的人力资源投资。

PAGE 4

RTL模型的性能评估依赖于周期精确的RTL仿真，典型的仿真速度在软件上为KHz，在fpga上为MHz。然而，XIANG SHAN在单个FPGA上完成50MHz的SPEC CPU2006仍然需要150多个小时，导致一周的迭代周期确实符合敏捷开发的要求。此外，与实际芯片不同，fpga存在CPU (50MHz)与DDR4(高达2400MHz)[51]频率比不一致的问题，使得fpga上的性能结果不现实。因此，研究如何准确、灵活地评估处理器的预硅性能具有重要意义。我们在第III-D节中演示了基于软件rtl仿真的性能评估工作流程。

3迈向敏捷工作流程使用平台:minjie

minjie是一个开源平台，旨在支持敏捷芯片开发工作流程，集成了一套丰富的现有和新开发的工具和工具链，用于逻辑设计，功能验证，性能建模，验证和调试，如图2所示。在本节中，我们详细介绍了用于敏捷验证、调试和性能评估的代表性工具的功能和设计方法，并描述了敏捷芯片开发的整个工作流程。

A.基于差分规则的敏捷验证(DRAV)

功能验证是确保芯片开发成功的关键。功能验证的关键是建立能够正确反映设计规范的参考模型(ref)。 图3的顶部显示了一个复杂的示例。根据RISC-V指令集手册，任何存储(PTE写入，存储退休)之前都有明确的防御。vma指令在虚拟地址转换过程(TLB Page Walk)中可能生效，也可能不生效(Store Complete)。这种灵活性使得翻译暂置缓冲区(tlb)和指令执行(正常提交或页面错误)的行为从外部看起来不确定，而这两种行为都是合法的。对于带有存储队列的RISC-V实现，TLB是否接收到PTE更新取决于PTE存储是否离开存储队列到内存子系统。然而，由于REF没有这样的微观架构状态，DUT和REF之间可能会出现行为上的分歧。 因此，验证策略必须解决微体系结构依赖问题:当REF缺乏足够的微体系结构状态并且与DUT的行为不同时，验证策略应该确定这种不匹配是由于真正的错误还是误报。

如图1(a)所示的传统模型通过设置各种简化的ref来解决这个问题，这些ref专门针对设计的某些部分。给定处理器P i, DUT和REF的行为都可以描述为微架构状态P i∈SP i在事件e∈e时的变化情况，其中SP i为处理器P i的微架构状态空间，e为事件空间，包括指令提交、异常、中断等。即DUT和REF都定义了从状态空间和事件空间到状态空间的映射RP i: R _ {P _ {1}}: S _ {P _ {1}} \times EarrowS _ {P} 验证是为了检查DUT和REF定义的映射的等价性，这意味着DUT和REF之间是1对1的对应关系。该模型对于商业处理器等设计很有用，它们具有较长的生产生命周期，其中验证ip和框架可以在整个项目中重用。 然而，由于开发周期短，特征变化快，资源有限，在敏捷开发模型中常见，如图1(b)所示，因此在REF和DUT之间保持1对1的对应关系是很困难的。 重新思考验证的原则，我们认为给定的设计规范可以导致不同的实现。因此，一旦被测对象的行为满足规范的定义，就可以允许实现细节的多样化，并放宽严格等效的要求。

遵循这一原则，如果具有不同实现细节的dut的行为符合相同的规范，则可以由相同的REF进行验证。给定一个规范P，如指令集，可以根据P建立一个REF，该REF定义了从s P∈SP开始的具有事件e∈e的合法架构状态转换，其中SP是P定义的架构状态。由于P中存在不同的微架构依赖行为，对于给定的当前状态s P和e, REF R输出一组下一个状态。也就是说, R: S _ {P} \times Earrow2 ^ {5} P

其中2sp为SP的幂集。给定一组处理器{p1，…， P n}，则可以很容易地找到从处理器微体系结构状态到体系结构状态的映射:f P i: SP i−→SP。因此，对于任意pi, i∈{1，…， N}，对处理器p1的验证就是检验f p1 (R p1 (s p1, e))是否∈R(f p1 (s p1, e))，这样dut和REF之间就形成了一个N- 1的映射，因为只维护了一个REF R，并且R比{R p1 |i∈{1更简单，…， N}}时，验证开销减少，如图1(c)所示。

PAGE 5

基于观察，我们利用差分规则抽象规范中定义的法律行为，并处理验证中的非确定性。diffi -rule r∈r在具有相同设计目标的不同硬件实现中是确定性的和稳定的。我们提出了一种新的基于difff规则的敏捷验证(DRAV)机制，该机制通过为RISC-V处理器提供验证基础设施和实际实现来增强传统的验证方法，如图3所示。DRAV机制由不同规则R、信息探针R和规则检查器组成，验证工程师可以自由地使用它们来表达他们对DUT和REF结果的期望。这些组件经过精心设计，可以在开源和敏捷硬件开发的背景下实现更高的效率。

B. RISC-V处理器的DiffTest: DRAV

1)概述:DiffTest是一个基于协同仿真的验证框架，如图4所示，它通过采用DRAV方法和放松来自设计规范的非关键等效性检查来加速验证收敛。具体来说，DiffTest提供了添加difft规则和动态重新定义参考模型的灵活性，因此可以扩展到同时支持多个设计。 DiffTest采用联合仿真模式，被测物和REF可以一个周期一个周期地同时运行，并通过探针和检查器形式的difft规则进行同步。在每个周期中，DUT结果(例如指令提交信息)由探针获得并传送给检查器。如果这个结果只有一个规则，REF将不会收到任何提示，因此结果将直接用于等价性检查。如果存在多个法律规则，并且DUT结果与其中一个规则匹配，则将触发REF执行与DUT相同的操作。一旦出现不匹配，检查机制就会识别DUT的潜在问题并终止rtl模拟。DiffTest可以快速地修改REF的依赖于微体系结构的行为，从而显著地降低REF的实现成本。

2)非确定性行为和diff规则:设计diff规则的关键挑战是识别非确定性微架构依赖行为的来源。幸运的是，它只影响验证效率而不影响正确性。为设计规则而识别的来源越多，REFs中验证所需的细节就越少。因此，可以通过添加更多的差分规则来不断提高效率。然而，我们需要在困难规则的数量和REFs和框架的设置成本之间进行权衡。 为了识别RISC-V指令集中机器模式CSR的非确定性来源，我们研究了RISC-V特权规范，并设计了至少120条规则，这些规则相对容易区分和设置，因为它们主要影响CSR读/写值。

PAGE 6

接下来，我们将介绍多核高性能处理器的ISA和总线级验证中几个代表性的不确定性来源。值得注意的是，试图覆盖更多处理器的差异规则是远远不够的，因为规则检查覆盖率的增加只会增加对正确性的信心，但永远不会确保正确性。相反，敏捷性通过提高工作流效率来解决验证问题，从而允许在固定的时间间隔内进行更多的验证试验。

a)推测性虚拟地址转换:图3显示了TLB的不确定性行为。具体来说，Linux选择在分配一个新的物理页之后不执行内存屏障指令，以避免在出现页错误异常[52]之前刷新指令。在大多数情况下，内存中的页表项(pte)会在存储指令退役后迅速更新。但是，如果更新PTE的存储操作在TLB访问内存时没有生效，则访问该页的内存指令将触发页错误异常，这将使处理器脱离正常执行而转向异常处理程序。两个差分规则用于解决这个问题:(1)即使REF没有触发，DUT也可能触发页面错误异常;(2) DUT和REF在执行同一指令后应具有相同的体系结构状态。

b)缓存层次结构和多核场景:由于并发内存访问的指数交错空间，加载和存储指令可能会产生不同的结果，因此无法与多核处理器构建健全完整的多核REF进行联合仿真。虽然内存一致性模型定义了大量合法的软件可见行为，但微体系结构细节决定了某些内存操作的顺序。我们利用差分规则来减少天文数字大的交错空间，并使用简单的单核REFs构建多核处理器的协同模拟框架。

例如，存储缓冲区是DUT和REF之间分歧或DUT的不确定性的来源。在RISC-V弱内存顺序(RVWMO)下，允许加载指令首先绕过私有存储缓冲区的值，如果绕过失败，则访问全局内存。一个朴素的多核联合仿真需要在REF中维护一个正确的存储缓冲区，除非DUT和REF之间的分歧经常会破坏联合仿真流程。在DiffTest中，我们设计了一个来自RVWMO规范的diffrule，它允许dut维护全局内存，并在它们不一致时更新REF内存。它引入了全局内存，用于记录进入DUT中的缓存层次结构的存储请求。数据正确性由全局内存和单核ref的本地内存检查。当单核REF执行与DUT值不同的负载时，DiffTest访问全局内存中相同的负载地址，以检查该负载值是否可能被其他硬件线程写入。如果是这样，该值将被更新到本地内存和单核REF中加载指令的目标寄存器。

除了RISC-V isa级的DiffTest规则和协同模拟之外，DiffTest还进一步增强了一致缓存层次结构的DiffTest规则。我们观察到缓存可以被视为黑盒，忽略内部实现细节。只要我们用一些额外的历史信息来监视缓存和核心之间的事务，就可以检查缓存的正确性。我们为缓存一致性设计了两大类规则。(1)为了界定在不同情况下收到的合法交易，根据总线协议规范建立了一系列规则。(2)根据cache一致性协议，维护权限记分板，跟踪每个数据块的权限。

c)更多的非确定性来源:我们有选择地选择一些在系统级REFs上实现复杂但相对不重要的微架构组件，并设计困难规则来抽象它们的行为。例如，我们在REFs中避免了大多数内存映射IO设备的细节、外部中断的来源、负载保留/存储条件(LR/SC)指令对的保留集[53]、宏指令融合[54]、性能计数器读取等等。在这些情况下，我们设计了宽松的差分规则来实现敏捷验证，其中DUT被信任以触发相应的事件。之后的体系结构状态由DiffTest检查，假设REF被强制触发相同的事件。例如，允许SC指令在LR和SC之间的超时时失败。由于它依赖于微体系结构状态，SC指令在DUT上的超时失败将是可信的，而此事件也会通知REF以调整其失败行为。

为了在验证处理器时利用diffi -rules，应该小心确保diffi -rules的健全性和对各种处理器实现的适用性。在页面故障和sc故障示例中，DiffTest都实现了更多的检查器来确保验证质量。跟踪强制页面错误和SC故障的数量及其在程序中的位置，并断言不会重复发生，以避免误报。此外，为了有效地验证这些组件，可以使用带有细粒度DiffTest规则的模块级DiffTest。例如，采用基于TLB设计规范的diffi -rules对TLB模块进行验证，形成多层次的验证方案。 3)信息探测:针对高级hdl导致的验证码破坏的第二个挑战，将DiffTest分解为diffi规则检查器和探测器，以自动提取所需的信息。如图3和图4所示，探针是放置在处理器设计中的一段逻辑。

PAGE 7

传统上，必要的验证信息是在广泛接受的通用验证方法(UVM)[16]下由监视器或适配器提取的。通常，它们是由了解验证需求的验证工程师手动编写的，他们会研究设计以找到感兴趣的信号。然而，在敏捷开发方法下，硬件设计可能会随着大量内部信号定义而频繁更改，从而导致验证工程师进行重复且无意义的移植工作。相反，探测器是由了解实现细节并承担推进设计责任的设计人员有意编写的。

像Chisel这样的高级hdl已被广泛采用，以加速硬件设计过程。如图3的探针定义部分所示，探针被注入到处理器设计中，并在与设计相同的高级HDL中作为本机接口实现。在Chisel代码自动生成特性的支持下，探针被定义为带有方向和类型的信号束，并根据该束的定义自动生成可实例化模块。当验证过程需要更多信息时，唯一要做的就是定义所需信号束的格式。然后生成接口，用于设计和验证之间的通信。

为了保持不同设计之间探针的兼容性，并随着设计的发展保持较低的维护成本，探针被设计为验证信息的基本构建块。例如，超标量处理器可以在每个时钟周期内执行和提交一条以上的指令。为了验证这些处理器，验证框架需要在同一时钟周期内提交的多个指令的信息。在我们的设计中，指令的信息探测被定义为仅用于一条指令的信息提取器，并期望在超标量处理器中实例化多次。通过这种方式，不同的处理器共享相同的基本探测，但探测的用法不同。此外，还隐式地向验证传递了一些静态设计信息。指令探测函数调用的次数表示被测超标量处理器的提交宽度。

在设计阶段将信息探针插入处理器设计中，并在rtl仿真期间提取详细信息。这些信息不仅可以用于DiffTest中的联合仿真和验证，还可以用于更多的调试工具。例如，ArchDB是一个基于sqlite的数据库，用于存储和解析探测获得的信息，其中的表由探测定义自动生成。ArchDB可以进一步用于过滤和可视化事件和事务，以实现敏捷调试。因此，随着探针的引入，设计和验证之间的信息差距得到了缓解。

C. LightSSS:按需调试

1)概述:调试需要的信息，如波形和日志减慢仿真速度，如第II-D节所述。为了解决这个问题，我们提出LightSSS，一个轻量级的模拟快照技术，用于快速模式和调试模式(调试信息启用)之间的按需转换。 图5演示了获取调试信息的各种方法。如图5(a)所示，由于获得了额外的调试信息，无论信息的格式如何，调试模式下的RTL-simulation通常比正常模式下慢得多。XIANG SHAN的一个例子表明，当启用波形时，rtl模拟速度下降到~ 8.5%，而导出文本日志也会导致模拟速度下降~ 55%。

如图5(b)所示，最先进的调试方法[35]并行运行两个相同的rtl模拟实例，其中一个实例(S0)比另一个实例(S1)晚启动N秒。当S0报告错误时，它通知S1打开波形等调试信息，并继续模拟，直到错误发生。由于S1与S0除了延迟N秒之外是完全相同的，所以当S1报告相同的bug时，我们可以获得仿真最后N秒(感兴趣区域，ROI)的调试信息。这种方法避免了大部分时间在调试模式下进行模拟，但需要双倍的计算资源。

2) MIN JIE的SSS:另一种关注ROI的现有方法是为rtl模拟拍摄快照，并按需恢复最近的快照，如图5(c)所示。快照通常是通过将电路状态和其他必要的仿真信息以包含所有所需信息的文件图像的形式连接起来创建的。然而，频繁地转储快照会导致严重的性能下降，最先进的rtl模拟快照工具LiveSim[55]报告了10%到20%的性能下降。闵杰还设计了一个电路依赖的快照格式SSS，性能开销为17%。每个快照都包含由Verilator[56]的可保存选项生成的DUT的整个电路状态以及DiffTest所需的其他验证状态，例如REF中的模拟内存。随着模拟内存的大小从256MB到16GB，快照开销甚至会增加，从而导致严重的I/O或内存压力取决于快照是否存储在磁盘上。 3)轻量级模拟快照:为了解决快照效率问题，我们进行了一个关键观察，即DUT内存的大多数内容在两个快照之间保持不变。因此，我们可以只记录两个RTLsimulation快照之间的不同状态，而不是存储整个快照。这一观察结果促使我们使用基于差异的内存快照。

PAGE 8

在本文中，我们提出了一种轻量级模拟快照(LightSSS)技术。如图5(d)所示，在rtl模拟期间，每N个周期周期性地创建快照。每个快照只存储其唯一的状态(差异)，并与其他快照共享相同的状态。因为我们只关心bug周围的区域，所以我们只保留最近的两个快照，并删除较早的快照，以减少开销。当报告错误时，rtl模拟进程通知旧快照以在调试模式下重播模拟，直到重新出现错误。这样，快照实例只需要重放最多2N个周期即可获得调试信息。 可移植性是SSS的另一个问题。链接到仿真的C/ c++外部模型需要手动保存和恢复细节。由于内部状态的高度复杂性和逐个实现的需求，很难移植它们。我们对LightSSS的一个关键见解是，基于软件的rtl模拟是一个运行在Linux内核上的进程，内核中的实用程序可用于电路透明快照。

我们使用Linux内核的系统调用来对rtl仿真过程进行快照，而不是对仿真电路进行快照。LightSSS定期从rtl模拟进程调用fork()，并将分叉的进程视为快照。当rtl模拟进程继续并更新内存内容时，写时复制(Copy-on-Write, COW)技术[57]本质上充当基于差异的存储:操作系统仅为修改过的页面分配物理页面，而在进程之间共享未修改的页面。通过使用系统调用来创建快照，我们避免了模拟电路的细节，并将快照方法推广到对任何dut和其他外部功能模型(如DRAMsim3)透明。 表1显示了用于软件rtl仿真的不同快照技术之间的比较。与现有的通用快照(如CRIU b[58])相比，LightSSS的设计和调优是为了灵活地调试rtl模拟硬件，并且由于内存中的特性而减少开销。与用于rtl模拟的快照工具相比，LightSSS造成的开销要小得多，因为它使用fork()实现了增量和电路不可知。 4)评估:关于LightSSS的开销有两个主要问题:(1)fork()系统调用引入了多少额外的运行时?(2)模拟过程发生分歧的频率是多少，对修改后的页面进行惰性复制的时间是多少?为了解决这两个问题，我们对单核XIANG SHAN和更大的双核XIANG SHAN进行了评估。 我们模拟了单核XIANG SHAN运行10次CoreMark迭代(约5.5分钟)，并模拟了双核XIANG SHAN启动SMP Linux(约30分钟)。AMD Ryzen 5950X处理器上的rtl模拟速度在单核(Verilator生成的c++代码行数为8.09M)下为5.1KHz，在双核(c++代码行数为15.47M)下为2.4KHz。 我们首先测量fork()系统调用的开销。由于COW，复制RTLsimulation进程只需要复制存储进程基本信息的进程控制块。正如预期的那样，fork()系统调用只需要535个线程。相比之下，第III-C2节中使用SSS创建快照需要3.671秒。

可以使用不同的快照间隔来评估COW机制的开销，通常从1秒到60秒不等。我们对每个间隔大小运行了十多次试验，但仍然观察到由于8线程调度[59]导致的性能变化很小。如图6所示，模拟时间几乎不受快照存在与否或快照间隔大小的影响。结果表明，LightSSS引入的开销比最先进的最先进的LiveSim[55]低一个数量级，后者报告的性能开销为10%到20%。

D. NEMU:性能评估的快速解释器

PAGE 9

预硅性能评估是高性能处理器的重要组成部分。跟踪和检查点早已在体系结构模拟器[60]中使用[61]，以增加仿真并行性并加快评估过程。为了准确和敏捷的性能评估方法，first MIN JIE提供了一个名为NEMU (New EMUlator)的高性能指令集解释器，它对不同的仪器和分析任务具有很高的灵活性。请注意，作为一个解释器而不是二进制翻译器，NEMU也可以用作DiffTest的一个易于开发的REF，以减少验证开销。其次，闵杰提出了一种新的架构检查点格式。minjie可以使用NEMU高效地生成检查点，并通过并行仿真实例恢复检查点。 1) NEMU设计:图7显示了NEMU的架构。它是一个线程代码解释器[62]，将所有执行例程(图7的右侧部分)内联到执行分派器中。为了实现高性能，NEMU采用了许多优化技术。 a)通过uop缓存优化Fetch和Decode:与用于缓存指令本身的指令缓存不同，uop缓存用于缓存一条指令的所有解码结果。这些结果包括操作数和执行例程(见图7和图7)。通过使用上缓存，NEMU只会在上缓存丢失时(见图7和图7)获取和解码指令。

为了减少上层缓存丢失的次数，NEMU进一步通过跟踪(动态指令序列)来组织上层缓存条目。例如，在图7中，PC从0x1000到0x100c的上缓存项是按顺序分配的(图7中为)。关键思想是通过分配具有特定地址的项来完全消除冲突遗漏。注意，对于传统的指令缓存，不同的地址可能映射到相同的项。因此，可能会出现冲突缺失，需要更换。因此，NEMU更有可能保持在快速路径上，这反过来又减少了读取和解码的次数。请注意，只有当上层缓存已满或发生系统事件(例如上下文切换)时，才会刷新它。这些事件在程序执行期间很少发生。

由于跟踪组织，NEMU可以通过向upc添加1来获取基本块内的下一个上层缓存条目(图7中的1)，这产生了良好的局部性。对于无条件间接跳转，使用哈希表根据目标地址查询上层缓存条目(图7中所示)。对于无条件直接跳转和条件分支，使用块链技术。一个例子是PC 0x2104 (beq指令)的上缓存项，如图7所示。哈希表的查询是在解码阶段进行的，这是一个缓慢的路径。

b)写零寄存器:RISC架构通常定义一个零寄存器，其值始终为0。为了实现这一特性，传统的解释器可能在写入GPR之前检查目标寄存器，或者为每条指令将零寄存器的值重置为0。相反，NEMU检查指令是否要在解码阶段写入零寄存器。如果是这种情况，存储在上层缓存中的目标寄存器的指针(解码结果的一部分)将被重定向到一个未使用的变量(如图7所示)。之后，执行例程将写入未使用的变量，从而保护零寄存器不被覆盖。 c)伪指令和压缩指令:对于一个伪指令，通常至少有一个操作数是恒定的或固定的。例如，ret是jair rd, imm(rs)的特殊情况，其中rd = 0(常量)，rs = ra(固定)，imm = 0(常量)。对于具有这种属性的指令，NEMU将定义专用的执行例程来内联这些操作数(如图7所示)。这种技术也可以应用于压缩指令。

d)浮点指令:NEMU利用主机浮点指令来解释来宾浮点指令。的执行例程。s指令可以用C语言中带有浮点数据类型的“+”来实现，它将被编译成多个主机(x86)的浮点指令。对于一些复杂的浮点运算，NEMU将调用数学库。一个例子是通过调用库函数fma()来实现融合的multiplyadd指令。

PAGE 10

2)评价:我们将NEMU与Spike [63] (git commit 6c18ef56)、QEMU-TCI (version 6.2.0)和Dromajo [27] (git commit fae7b3a1)进行比较。其中，Spike是最先进的RISC-V解释器。QEMU- tci是QEMU的解释器模式[64]。Dromajo是BOOM的参考模型。对于软件缓存大小的配置，我们对Spike运行了1024到32768的不同大小，由于效果最好，选择了16384。NEMU也采用这种大小的上缓存。这个大小不适用于Dromajo，因为Dromajo中没有缓存。我们使用QEMU-TCI的默认缓存大小。我们在英特尔酷睿i9-9900K CPU的服务器上运行这些解释器。

SPEC CPU2006基准测试套件在用户模式下使用测试输入集运行，其中系统调用由仿真处理。NEMU和QEMU-TCI通过管理来宾内存和将大多数系统调用转发到主机操作系统，从而为用户模式提供了本地支持。Spike在一个代理内核模块riscv-pk[65]的帮助下支持用户模式。Dromajo默认不支持用户模式。我们以类似于NEMU的方式增强它。我们不包括400。Perlbench和435。由于riscv-pk中未实现的系统调用而导致的gromac[66]。

如图8所示，在Spike、QEMU-TCI和Dromajo中，Spike表现最好。对于SPECint 2006, Spike平均可以达到142 MIPS(每秒百万条指令)。同时，NEMU最终平均可以达到733 MIPS，约为Spike的5.16倍。在SPECfp 2006中，Spike的运行速度甚至更慢，只能达到106 MIPS。这是因为Spike通过调用SoftFloat[67]来解释一个浮点指令。通过采用主机浮点指令，NEMU在浮点基准测试中可以达到817 MIPS，约为Spike的7.71倍，某些基准测试(410.bwaves)甚至可以达到16倍。 3)检查点用例:MIN JIE定义了一个RISC-V isa级架构检查点格式，只有基本的RV64特权指令，如图9所示。与现有的公开可用的检查点格式[27]相比，我们的检查点格式独立于RISCV调试模式[68]，能够启用没有外部调试功能的早期处理器。例如，CoreMark-PRO的检查点[69]可以使用NEMU以bb0 300 MIPS的速度有效地生成。

我们进一步采用SimPoint[70]对指令片段进行采样。请注意，在NEMU中计算基本块向量很容易，因为在解释器中收集有关指令的信息很简单。我们使用选定的检查点模拟处理器设计，并计算每条指令的加权周期(CPI)以进行性能验证。这种基于检查点的评估流程必须解决微建筑升温和采样代表性问题[71][72][73][74][75]。在预热期间，分支预测器和缓存等组件中的微体系结构状态通过执行硬件上的指令来更新。未来的工作是用更少的时间和更少的计算资源达到更好的性能估计精度。

通过并行化基于软件的rtl仿真实例，可以同时模拟大量的检查点。使用5个128核服务器和约1K检查点来实现100%的集群覆盖率，我们可以在三天内估计SPEC CPU2006的分数。相比之下，香山在单个50MHz的FPGA上完成SPEC CPU2006程序需要150多个小时，其价格与5台x86服务器大致相同。如果我们将聚类覆盖率降低到80%，则可以在24小时内获得初步评价结果。评估结果的准确性将在第IV-B节中进行论证。

E.把它放在一起

如图2所示，闵杰集成了一组开源工具，通过提出敏捷工具来增强传统的验证方法，这些工具支持由高级语言实现的设计的功能仿真、软件仿真和基于fpga的原型的高效性能建模和验证，以及在开发流程的每个步骤中调试指标。 我们详细演示了功能验证的工作流程。当实现新特性时，开发人员只需要启动rtl模拟，这些工具将被自动调用。如果从DiffTest中没有报告错误，那么在相应的测试用例上，设计很可能与设计规范保持一致，并且性能结果可以进一步分析。否则，LightSSS将提取波形和日志等调试信息。我们开发和开源了更多的调试工具，更好地支持Chisel (ArchDB，波形终结者等)。开发人员可以使用它们来进一步调查潜在的错误。 闵杰还集成了性能评估工具包，用于夜间性能回归。通过选择具有代表性的检查点，精确性能验证的到结果时间大大缩短，进一步加快了高性能处理器的设计空间探索。目前，minjie主要采用基于RTL仿真的验证流程，我们认为这是对模拟器和fpga上的工作流程的本质补充。

构建一个开源的高性能处理器

PAGE 11

为了证明闵杰的有效性，我们使用它构建了一个高性能的RISC-V处理器，名为香山。自2020年6月起，我们分别开发了代号为YQH和NH的两代产品。本节介绍了香山的微结构细节以及我们与闵杰和香山的经验。

答:微架构

XIANG SHAN是一款支持RV64GCBK ISA的超标无序RISC-V处理器。作为敏捷开发的第一步，XIANG SHAN使用Chisel HDL[76]实现，总代码行为~ 63K。两代“香山”的微架构参数见表2。值得注意的是，大多数设计参数都是基于给定的时间限制、面积和预算(如缓存大小)进行配置的，而表2分别显示了我们用于YQH和NH微架构的目标频率为1.3GHz和2GHz的磁带输出的参数。

第二代象山NH的微架构图如图10所示。可以看到，在前端，它具有分支预测单元(BPU)和指令提取单元(IFU)的解耦风格，其中BPU运行在前面并提供足够的指令提取请求。XIANG SHAN使用带有间接跳转预测器的4表16k条目TAGESC分支预测器。在解码阶段，利用宏op融合，将若干连续的算术指令融合为单个微操作，以减少执行延迟，增加各种缓冲区的有效大小，如重排序缓冲区和发布队列。

PAGE 12

XIANG SHAN实现了通用寄存器文件和浮点寄存器文件的分离。移动消除是通过整数物理寄存器的引用计数机制实现的。保留站分布和分组为32条或16条的较小的保留站，每个时钟周期向执行单元发出两条或一条指令。浮点乘加(FMA)指令在级联FMA单元中执行[77]，具有5个周期的延迟。FMA指令允许在乘法操作数准备好时提前执行，并在第三个操作数准备好时再次发出。

在内存子系统中，两个负载管道是银行交错的。存储被解耦为数据和地址微操作。L1 DTLB有128个直接映射表项和8个完全关联表项，以确保更大的容量，而不会对计时产生负面影响。XIANG SHAN有一个128KB虚拟索引物理标记(VIPT) L1指令缓存和一个VIPT 128KB L1数据缓存。我们设计了一个基于硬件的解决方案来解决大型VIPT缓存中的混叠问题。L2缓存和L3缓存都是非包容性的。 作为“香山”的第一个版本，YQH于2021年7月推出了28纳米CMOS技术，工作频率为1.3GHz。表III列出了CPU核心的物理实现统计信息。(b) 2006年SPECfp分数的布局 YQH芯片和核心如图11所示。 作为第二代象山，NH是一种双核实现，将于2022年第四季度在14nm CMOS技术上以2GHz的目标频率停产。NH的布局如图11(d)所示。

b .性能

图12显示了在SPEC CPU2006基准测试套件下香山处理器的性能评估结果。它是用-O2优化标记编译的，YQH的ISA为RV64GC, NH的ISA为RV64GCB。我们使用被广泛接受的SPEC/GHz度量[25][78][79]，它与IPC[6][80]成正比，用于定量评估。 YQH芯片如图11(c)所示，于2022年2月成功提产。结果(图12中的YQH-ASIC-DDR4-1600)表明，在1GHz下，香山在specp2006上达到7.03，在specp2006上达到7.00。 此外，我们还对“香山”在FPGA上的性能进行了评估。凭借90时钟周期的固定和平均内存访问时间(AMAT)， YQH在SPECint 2006和SPECfp 2006上分别实现了6.87/GHz和7.23/GHz的标准化。 凭借4MB的最后一级缓存(LLC)和250个周期的AMAT, NH在SPECint 2006和SPECfp 2006上分别实现了7.94/GHz和9.27/GHz的标准化。为了演示LLC大小如何影响性能并验证仿真中的6MB LLC统计数据，我们使用2MBLLC进一步评估NH。如图12所示，与NH2MBLLC-FPGA-250C-AMAT相比，NH- 4mb - fpga - 250c - amat在SPECint和SPECfp上分别实现了8.9%和5.4%的性能提升。

PAGE 13

如第II-E节所述，FPGA上的DDR运行频率为1.6GHz，而CPU运行频率为50MHz，导致DDR访问延迟为一个ecpu周期。尽管我们手动为内存请求添加了250个填充周期，但访问延迟和带宽仍然与实际芯片不匹配。在FPGA原型平台上，大多数读写请求具有较长的延迟，而内存带宽是无限的。由于程序特性和对内存延迟的偏好，SPECint 2006在FPGA上的评估是保守的。

除了硬件测试，我们还可以在闵捷的支持下使用软件来评估性能。利用第三节- d3中介绍的工作流程，我们使用DDR4-2400在rtl仿真环境下评估“香山”的性能。YQH在1.3GHz时达到7.67/GHz的SPEC分数，NH在2GHz时达到10.06/GHz的SPEC分数。与fpga和真实芯片的结果相比，使用MIN JIE提出的评估方法的偏差为5% ~ 10%。这是可以接受的，因为内存配置不一致。 据我们所知，NH实现了开源RISC-V处理器的最高性能。

C.调试闵杰

在本节中，我们将在XIANG SHAN的回归测试中演示闵杰使用bug的有效性。虽然我们已经对二级缓存进行了全面的单元测试，但这个bug仍然逃到了系统级测试。 当在双核XIANG SHAN上运行Redis基准测试[81]超过168小时后，经过3B个模拟周期，这个复杂的bug就暴露出来了。使用章节III-B2b中描述的DiffTest规则报告DUT和全局内存之间的数据不匹配。之后，激活LightSSS (Section III-C3)生成的倒数第二个快照以重新运行rtl模拟。在启用波形的情况下，模拟最后的30.8K周期只需要3分钟。

调试阶段从第III-B3节中提到的ArchDB开始，它在多级缓存中记录事务信息。我们发现，在同一缓存块中，从L2缓存到L3的Acquire[82]请求与从L3到L2的Probe事务重叠。虽然L2从L3获取正确的数据，但后来它向上授予L1错误的数据，这表明仲裁逻辑中存在错误。对波形的进一步调查证实，当来自L3缓存的Probe和GrantData到达特定时间间隔时，L2 MSHR不能正确处理重叠。

本案例演示了minjie如何在复杂处理器的验证和调试中获益。对于适用于单核和多核场景的DiffTest，在处理器运行实际程序时可能会暴露错误。LightSSS大大加快了错误再现的速度，如果没有它，可能需要额外的16 ~ 32小时来转储快照(使用LiveSim或SSS)。ArchDB等工具进一步提高了硬件调试的效率。值得注意的是，FPGA上的DiffTest可以极大地提高测试吞吐量，这是闵杰未来的重要工作。

D.特征探索

在本节中，我们通过案例研究展示了闵杰和香山的能力，并表明它们可以作为敏捷硬件开发和高性能处理器研究的架构创新平台。在这个平台上，我们实现并评估了一种微架构技术，该技术于2018年提出，旨在提高无序处理器的性能。本案例旨在证明，创新理念在香山可以很容易地实现和评估，闵捷显著加快了开发进程。

1)实验设置:我们使用Chisel语言并重用XIANG SHAN代码库中的基本实用程序来实现这些想法。由于两个原因，我们的实现可能与原论文所呈现的有所不同。一个原因是最初的实现是基于架构模拟器的，它比真正的RTLlevel处理器实现包含的细节要少得多。另一个原因是，我们主要是为了概念验证而实现这个想法，并不打算复制与原始作品相同的结果。为了评估这一思想，我们选择了具有代表性的SPEC CPU2006程序检查点，并使用Verilator对香山上实现生成的rtl代码进行了仿真。评估是在128核x86服务器上完成的。 2)优先考虑不可靠的分支切片:现代处理器使用分支预测技术来提高性能，通过提高预测精度或减少错误预测的惩罚。与此同时，OoO处理器有一个大的指令窗口，无论程序顺序如何，都可以调度就绪指令。不同的指令对整体性能的影响是不同的，即临界性。

人们提出了各种问题策略，首先发布关键指令。Hideki Ando提出了优先排序不确定分支切片(PUBS)[83]，目标是通过优先问题策略减少分支错误预测的惩罚。我们的见解是优先考虑不可靠的分支指令和其操作数的生产者指令的问题。不可靠分支指令是指分支预测精度较低的指令。生产者指令影响分支指令的操作数准备就绪的时间。如果能尽快发布生产者指令，不可靠的分支就能更早解决。

PAGE 14

为了跟踪不可靠的分支指令并以更高的优先级发出它们，PUBS包含四个基本组件，包括置信度估计表ConfTable、分支切片表BrSliceTable、定义表DefTable和优先级问题策略PriorityIssue。每条指令查找brslicettable中与其相关的分支指令，并检查预测置信度。如果置信度低，则该指令具有高优先级。酒馆最初是在SimpleScalar模拟器上实现和评估的。根据论文的报道，对于每公斤指令的分支错误预测(MPKI)超过3.0的SPEC CPU2006程序，PUBS将性能提高了7.8%。 在闵捷平台上，我们采用敏捷开发方法在西安市实现了酒吧。我们将任务分解为四个特征，可以迭代地实现，如图13所示。用大约300行修改后的Chisel代码，在不到200分钟的时间内实现了香山上的酒馆。 为了评估酒吧的性能，我们从speccpu2006中选择了具有代表性的检查点，并在酒吧的香山上运行它们。我们的第一次尝试是在seng的10个检查点上，这是在PUBS论文中被认为是加速速度最高的程序。我们模拟了20M的热身指令和下面20M的性能分析指令。本实验以年龄为基线;也就是说，最早的指令被安排用于具有最高优先级的问题。 如图14所示，我们没有观察到在jeng上的pub有任何明显的性能偏差，尽管pub论文报告的IPC比基线1提高了6.5%。然而，这个结果在某种程度上是可以接受的，因为我们使用的是XIANG SHAN的默认配置，这与bars论文中使用的处理器配置有很大的不同。例如，XIANG SHAN采用了更大的指令窗口和更宽的问题宽度，减少了问题策略对性能的影响。 为了证实我们的猜想，即在XIANG SHAN上较大的问题宽度会降低加速，我们研究了从模拟中获得的详细性能计数器。XIANG SHAN实现了一个分布式问题队列，每个队列允许在一个时钟周期内发出两个就绪指令。图15显示了可以安排发布的指令数量的时间分布。为

seng的10个检查点，能够发出2条以上指令的情况占总周期的12.8%，平均阻塞指令数为0.215条。同时，平均有5.9%的指令被标记为高优先级。因此，阻塞高优先级指令的平均数量为0.215 × 5.9%。此外，假设当有两个以上的就绪指令时，在每个周期阻塞一条指令，则该指令的预期阻塞周期最多为0.168。因此，在使用PUBS的一个时钟周期中，大约少于1.3%的指令可以被提前调度。这一小部分指令和更少的分支指令不会带来显著的IPC改进，与图14中的评估结果相匹配。 我们还评估了在XIANG SHAN的更多配置中MPKI超过3的其他检查点的酒吧，但没有观察到明显的性能改进。

minjie使开发人员能够使用他们熟悉的工作流程作为体系结构模拟器，同时通过使用周期精确的rtl模拟器来实现香山高性能微体系结构的更精确。首先，Chisel显著提高了代码密度和编程效率。酒馆只需要300行Chisel代码，包括许可头、空行和性能计数器的定义。其次，DiffTest和LightSSS可以在不破坏其他部分的情况下对新特性进行快速功能验证。例如，修改后的问题策略中的潜在问题触发由DiffTest框架捕获的断言。然后，模拟被中止，但LightSSS恢复最近的快照并输出调试信息。信息的自动获取大大加快了调试过程。第三，SPEC CPU2006中的代表性检查点允许我们在数小时内评估pub，并且可以从模拟中获得详细的性能计数器。

五、相关工作A.硬件描述语言

PAGE 15

最近提出的硬件描述语言提供了高级设计范式[84][85]。Bluespec SystemVerilog[86]提出了受保护的原子操作，允许编译器为硬件方式选择调度程序并发出优化的硬件设计。基于Python的hdl[87][88][89]在Python中提供参数化的硬件结构描述。基于scala的硬件构造语言[76][90]提供了灵活的面向对象和函数式编程特性。Chisel采用FIRRTL[91][92]中间表示，通过定制电路变换对电路进行优化。传统语言和新兴语言都可以在MIN JIE上使用。

B.仿真和硬件验证

硬件验证采用静态和动态两种方法。静态和形式化方法能够证明理论正确性，但存在状态空间爆炸的局限性[93]，不适合大规模电路。基于动态rtl仿真的验证是最常用的工具，它可以进一步分为正确性检查和生成测试用例。 为了提高rtl仿真的效率和增强正确性比较的能力，提出了各种框架。FireSim[31]是一种fpga加速仿真技术，运行在公共云上，以更低的成本提高可用性和弹性。在FireSim之上，FirePerf[94]提供了一组系统级性能分析工具。可合成断言和打印语句b[35][38]已在fpga上实现，以解决可调试问题。除了FPGA方法外，基于软件的仿真对于硬件验证也很重要，一些工作已经解决了其效率问题[95][96]。 已经为RISCV[97][98][99][100][101]和其他处理器提出了测试生成方案，它们与之前介绍的框架并行工作。此外，还采用了模糊测试[102][103][104]和机器学习[105]等技术来有效地生成更高质量的测试用例，以获得更好的覆盖率。目前，MIN JIE和XIANG SHAN使用的是现有的开源测试生成框架。

C.新hdl和RISC-V的验证

像Chisel[106][107][108]这样的高级hdl的本地验证框架已经被提出以提高开发敏捷性。Mamba[109]提出了一种即时编译器来直接模拟高级PyMTL代码，达到与商用HDL模拟器相当的性能。这些框架旨在为通用验证提供高级接口，而不针对任何特定设计[110]，这与闵捷是正交的。 RiVer[111]提供了一个基于python的验证环境，支持运行测试并将结果与有效的参考模型进行比较。然而，RiVer并没有提供测试生成器和参考模型的任何实现。Dromajo[27]是RISC-V处理器的最先进的协同仿真框架，并提供Logic Fuzzer以实现更高的覆盖范围。然而，它在联合仿真期间依赖于确定性的体系结构状态，并手动将外部中断发送给REFs，这是唯一确定的发散源。相比之下，我们提出了一个关键的观察，即发散是共同模拟的规范，并提出了差分规则来解决一般的不确定性问题。与Dromajo相比，minjie识别了更多的非确定性来源，并支持更复杂的联合仿真场景，如多核和缓存层次结构。

D.敏捷开发平台

为了各种目的，已经提出了集成和敏捷开发平台[8][11][12]。Chipyard[7]是一个集成的SoC设计、仿真框架，包括许多RTL生成器，如BOOM[7][112]和Hwacha[113]以及验证工具[114][115]。现有的平台和工具对开发人员来说一直很有价值，闵捷采用了一些现有的开发工具。本文在复杂处理器验证方面进一步推动了敏捷开发的研究。闵杰提出的方法和工具是对社区现有工作的补充。

六。结论

在本文中，我们提出了敏捷，一个高性能芯片设计的敏捷开发平台，和翔山，一个高性能的RISC-V处理器。minjie为敏捷开发工作流程集成了一套广泛的工具。通过采用敏捷方法，香山以更短的开发周期和有限的工作量实现了具有行业竞争力的性能。我们正在开发代号为KMH的第三代象山，其目标是3GHz的SPEC CPU2006 15/GHz。MIN JIE和XIANG SHAN都是开源的。

鸣谢

作者要感谢匿名审稿人提供的宝贵反馈和意见。我们也特别感谢我们的小组成员，何逸飞，胡璇，张子玥和甄浩，他们在工作上的帮助。本研究得到了中国科学院战略重点研究项目(批准号:No. 9502)的部分资助。XDC05030200)，国家自然科学基金项目(批准号:62090020,62172388,62072433)，中国科学院青年创新促进会项目(2020105)，信息通信技术创新专项基金E261100，中央高校基本科研业务费专项基金项目(批准号:62172388,62072433)DUT21RC(3) 102年,DUT21LAB302)。

附录答:抽象

PAGE 16

minjie是一个支持敏捷处理器开发的开源平台。“翔山”是闵杰研发的高性能RISC-V处理器。我们与闵杰一起演示了香山的功能验证和性能评估的工作流程，包括DiffTest, LightSSS, NEMU和RISC-V检查点等工具。 B.工件检查表(元信息) •硬件:x86-64 Ubuntu服务器 •实验:(1)在双核香山上进行DiffTest;(2) LightSSS调试及性能开销评估;(3)基于SPEC CPU2006检查点的香山性能评估;(4)香山酒吧的评价 •代码许可:Mulan Permissive Software license, Version 2 •存档:10.5281/zenodo.7030506 •在线:最新版本在GitHub上维护

c .描述

XIANG SHAN和MIN JIE在GitHub上是开源的。在Zenode中提供了工件的存档版本，它被用作本附录中的示例。 由于专有问题，我们不能公开提供完整的数据集，例如用SPEC CPU2006生成的可执行RISC-V检查点和FPGA原型的源代码。

d .安装

1)安装工具链:需要一些软件包来构建香山和使用闵洁。

E.实验工作流程

1) DiffTest (Section III-B):我们用DiffTest模拟双核XIANG - SHAN，它可以实时检查正确性并报告REF和XIANG SHAN之间的任何不匹配。我们故意在XIANG SHAN中注入一个错误，它将触发一个被“缓存层次和多核”捕获的错误 “场景”-规则(Section III-B2b)。 2) LightSSS (Section III-C):首先，我们验证了LightSSS这一仿真快照机制的功能正确性。我们模拟了与之前实验相同的工作量的双核XIANG SHAN。当模拟终止时，LightSSS将恢复快照(由fork创建的子进程)并重新运行模拟的最后几秒钟以生成波形和调试日志。 其次，我们评估LightSSS的性能开销，以重现图6中的结果。我们将用两种配置(单核和双核)来评估LightSSS。 其次，我们评估了NEMUs生成RISC-V检查点的性能。 第三，我们以CoreMark-PRO为例验证NEMU能够生成RISC-V检查点。 我们还确认XIANG SHAN能够恢复并运行生成的RISC-V检查点。 4) XIANG SHAN (Section IV-B):图12中的XIANG SHAN处理器的性能在三个平台上进行了评估，即RTL-simulation, fpga和芯片。 由于特殊的硬件和专有软件需求，我们现在不能公开共享数据集，包括用于性能评估的检查点。然而，我们鼓励从源代码构建SPEC CPU2006，并使用NEMU和SimPoint生成检查点。 首先，我们使用SPEC CPU2006预生成的检查点来估计YQH和NH的性能。 要估计NH的性能，请运行上述步骤，但将目录替换为A.5.4-XS-NH。 其次，利用FPGA平台对YQH和NH的性能进行了评估。使用A.5.4-XS-FPGA-YQH, A.5.4-XS-FPGA-NH-2MB和A.5.4-XS-FPGA-NH-4MB目录来重现YQH-FPGA-90C-AMAT, NH2MBLLC-FPGA-250C-AMAT和NH-4MBLLC-FPGA-250C-AMAT配置的性能数据。 5)酒吧(章节IV-D):我们使用SPEC CPU2006中的seng检查点来评估酒吧，如图14和15所示。三个目录(A.5.5-PUBS- baseline, A.5.5-PUBS-AGE- only, A.5.5-PUBS)上有三种配置，即(1)baseline， (2) AGE和(3)AGE+PUBS。它们被一个一个地求值。

F.评价和预期结果

PAGE 17

1) DiffTest (Section III-B): DiffTest应该以“ICache Re fill test failed”终止。 对于性能开销评估，模拟时间应该在不同的快照间隔中保持稳定。 3) NEMU (Section III-D):首先，我们验证NEMU在1200 MIPS左右解释SPEC CPU2006中bzip2的测试输入，如图8所示。其他指令集模拟器的性能由包装器脚本报告。结果表明，NEMU的运行速度比其他算法快得多。 其次，用于检查点的NEMU的性能在10B条指令之后报告。预计大于300M instr/s。总共应该在output_top/test/coremarkpro中生成8个RISC-V检查点，并在香山上正确运行。 4) XIANG SHAN (Section IV-B):首先，可以使用脚本来打印带有RISC-V检查点的rtl模拟的估计分数。预计在YQH上为~ 7/GHz，在NH上为~ 10/GHz。 其次，SPEC基准测试的运行时间显示在串行端口中。总SPEC分数被计算为基准的GEOMEAN。预计在YQH上为~ 7/GHz，在NH上为~ 10/GHz。 第三，我们提供了一个Python脚本来报告YQH芯片上的SPEC分数。预计为~ 7/GHz。 5)酒馆(Section IV-D):性能计数器在sjeng_*.csv文件中生成。图14是由全局的。IPC。图15是由全局的。num_ready_frac_ *线。

g .笔记

香山和闵杰都是在开源社区开发的。目前，由于专有问题，我们不能公开分享完整的数据集。然而，我们正在努力提供一个可公开访问的版本，一旦我们完成，就会在GitHub上分享它。
