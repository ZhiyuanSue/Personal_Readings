原文链接先放上

https://os.inf.tu-dresden.de/pubs/sosp97

# 摘要

大概就是L4微内核上面跑Linux和Linux原生以及MKLinux进行比较

以及这篇文章说到底，就是L4Linux的实现的报告，不是什么对微内核的性能分析（不要标题党）

MKLinux在我阅读Darwin内核的时候接触过，大概就是某个乔布斯时代的上古老古董（好吧这篇文章也很老古董）

# 简介

反正纯微内核已经被放弃啦，据说是性能太糟糕

纯微内核要么层次太低搞一大堆东西来隔离，要么太高，就是基于各种硬件架构去搞微内核去忽略可移植性

第一代微内核是基于单片内核

第二代微内核QNX和L4

本文章做了这么几个事情



单片类的Linux被放在L4上面作为用户级服务器运行，让他可以进行性能比较

可扩展性

L4抽象的可移植性，独立于奔腾平台，所以跑到21164架构上面重新实现了一个

# 具体实现

目标：兼容性测试，任何现成的Linux软件都要到L4Linux上直接就跑

页表在L4中重做了一个，唔，感觉类似虚拟化的双重页表一样（我打赌如果让当初这篇文章的作者在现在用虚拟化实现一遍L4Linux肯定会有别的做法）

L4Linux仅仅用单个L4线程，Linux内核支持多线程的调度，但是如果支持同时并行跑Linux，可能会改原有的Linux内核，所以作者说不干。

L4允许特权用户级任务禁用中断。

驱动，可以直接重用Linux的驱动

Linux用户进程每一个都当做L4任务来实现

系统调用

使用远程过程调用，让用户进程和Linux服务器之间进行IPC

包括libc.so

libc.a

用户级异常处理

前两种稍微快一点，最后一种则是二进制兼容性

内存映射，避免了TLB的清理，提高性能。

信号

Linux通过直接操作堆栈堆栈指针和指令指针传递信号。

调度器

Linux内核调度器没啥用。L4调度器用了4个优先级，中断上半部，中断下半部，Linux内核，Linux用户进程。这样的一个状态来调度。

带tag的tlb——这是为了处理上下文切换的用户空间TLB清洗的问题。



# L4Linux早期实现的一个重大错误

单空间方法和双空间方法

这个我看了半天，我的理解是，Linux中系统高地址用于存放内核，而低地址用于存放用户空间的代码。服务器就是Linux内核在L4上的内容

作者原本认为复制服务器上的内容太过昂贵，所以做了一个映射？？？

但是复制服务器需要额外的同步，这需要时间

所以最后发现，不复制服务器的空间，也就是Linux内核上的内容不复制到用户空间，作为可以访问的代码。

总而言之，这样性能更快一点

（这段理解的我很头痛）

# 性能问题

那不就是结论嘛

好吧，mach是什么渣渣。。。

总而言之，起码L4Linux比起Linux最坏也就是两倍，但是MKLinux实在是一言难尽

普遍而言比Linux多了5%到10%左右。

后面还做了一大堆的实验，但是总而言之，性能差别不大。
