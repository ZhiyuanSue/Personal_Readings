# 摘要

目前已经有8个虚拟机了，但是这8个虚拟机，都有不同的驱动接口，因此使用virtio设备来解决

vring：用于环形缓冲区



他们需要的设备包括块设备，网络设备和控制台驱动程序。

有时候需要frame缓冲器，有时候需要巴拉巴拉别的设备

但是他们提供的功能，基本相当只是略有不同

而且仿真设备又很没有性能优势



# 三个目标

一个是在linux下

一个是提供一个通用的ABI

一个是提供了两个完整的ABI实现



# VIRTIO在Linux中提供的抽象

将自己注册为特定的32位设备

传入一个struct virtio-device结构体，本身具有virtio_config_ops

配置操作分为

读写特征位

读写配置空间

读写状态位

复位设备



这些特征位必须被显式的声明



第二部分是配置空间

这就是相当于配置设备的一些东西了，比如设备会被guest用户配置一个读和写的MAC地址。



还有一个配置和设置8位设备状态字的功能

用于指示设备probe的状态

如果是VIRTIO_CONFIG_S_DRIVER_OK状态，就被认为probe已经成功了



最后是复位



## virtqueue

他有几种操作，从队列中操作buf

add_buf

get_buf

disable_cb相当于关闭中断

enable_cb



## virtio-ring

使用描述符



还有一个vring_avail结构体

和一个ving_used的结构体

有一个描述符，和可用环的分离（一下子没看懂）

是由于virtqueue的特性



我看了后面的示例，大概就是，描述符表指向具体的东西

然后available和used指向这个描述符表



然后呢，就是对这个virtio设备



## 零拷贝

这里的关键在于，VIRTIO试图专注于只把发布缓冲区这件事情做好

他所期望的是，一个数据，对于guest而言，期望IO速度和主机进程IO一样快。

所以他试图做页面映射来搞零拷贝



查了一下，还有一个NetVM，是NSDI的论文



# 例子

## 块设备

这里的关键点在于，请求，以及struct virtio_blk_outhdr，以及一个字节的状态

这三个连在一起

放在三个空闲条目中

然后配合使用available和used两个结构体。

## 网络设备

网络设备我就不说了

感觉问题没那么严重。

