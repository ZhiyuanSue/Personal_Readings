# 第一章

就普通介绍一下虚拟化

# 第二章 x86

其他都差不多

注意APIC

最初的8259A是PIC，具有IRR，ISR，IMR等寄存器可以读写

APIC则是一个IOAPIC和LAPIC，注意他在虚拟化情况下。

网上也有一些相关的说明

IOAPIC 内部包含了一系列的寄存器，这些寄存器通过 MMIO 机制映射到系统存储域的 0xFEC00000 处，其 Index、Data、IRQPin Assertion 和 EOI 寄存器可以直接访问，其他寄存器需要通过读写 Index/Data 寄存器方式访问，具体访问是通过先将 8bit 索引写入到 Index 寄存器，然后从 Data 寄存器读写对应的内容.

包括直接可以访问的和不可以直接访问的两个部分的寄存器

不可访问的启示主要是PRT表，需要配置，里面对24个外设中断都有配置一个RTE寄存器，该寄存器有个Vector字段，指明IDT表的下标，范围为0x10 到 0xFE.也就是，只能触发32到255之间的中断



vIOAPIC（后面会讲到）

GSI（为系统中每个中断源指定一个唯一的中断号



时钟系统，x86配置了好多个，额，丰富的时钟

HPET，和32个比较器匹配器，配置成32个channel，需要禁用低精度时钟，用高精度时钟模拟低精度时钟



# 第三章 虚拟化

陷入再模拟：如果所有敏感指令都是特权指令，将VMM运行在高特权级，客户机os运行在非最高特权级，直接陷入即可

判断一个架构是否可虚拟化，主要在于其对敏感指令的支持上，即所有敏感指令都是特权指令，那么就可以虚拟化

否则存在虚拟化漏洞



虚拟处理器



VMM对中断的模拟和注入

虚拟中断源和设备模拟器，设备模拟器会在VMM在特定时间，检查虚拟中断控制器的状态，决定是否中断注入，包括处理器内部虚拟中断，处理器外部虚拟设备的中断。



还需要缓存中断，例如如果某个地方屏蔽了中断并且这些中断不能合并，那么需要缓存



SMP的模拟

VMM面临着物理处理器和虚拟处理器之间同步的问题，因为他可能运行在多个核心上来模拟vcpu

如果这样，VMM自身需要负责处理这些问题。



对于启动，如果客户机OS不可修改，那么需要完全实际的按照手册去模拟，如果可以修改，可以跳过一些步骤去初始化主cpu，然后去唤醒其他的AP



对于内存，最简单的是让其访问物理地址空间每次都触发异常



IO虚拟化

设备发现（虚拟设备）

有两种，一种是硬编码的东西，这部分需要驱动程序直接读取某个端口，或者某个地址，而对此的操作则是需要正确的模拟这些位置的值即可

另一种则是软件资源可以配置的，比如PCI设备，就是可以配置的，这部分VMM需要模拟例如PCI的行为等等，从而让他可以被发现



对于设备读写的截获

如果是IO端口，x86可以直接禁用这些端口的位图，从而触发异常

但是如果是MMIO，因为这是映射到页表上的，所以需要把这个页表设为无效，然后会触发VMMexit，然后再发到设备模拟器进行模拟



对于中断，如果直接确定分配给这个设备了，直接通知即可

如果不确定，则需要进行判断并注入



设备模拟

前端和后端

客户机OS的驱动是前端，VMM中的就是后端

本来这个我不太明白，但是他说是基于请求和事务的，大概就了解了，原先寄存器每次读写都得改，但是通过这个前后端的方式，就可以把一堆操作变成一个请求，从而提高性能



设备共享



虚拟资源的管理

包括处理器虚拟化，内存虚拟化，设备虚拟化



调度

虚拟机通信



物理资源的管理



虚拟化分类

完全虚拟化：

软件辅助虚拟化，优先级压缩和二进制代码翻译相辅助，优先级压缩由于x86本身没有最初设计为可虚拟化指令，所以需要二进制代码翻译搞事情。

硬件辅助虚拟化



类虚拟化








