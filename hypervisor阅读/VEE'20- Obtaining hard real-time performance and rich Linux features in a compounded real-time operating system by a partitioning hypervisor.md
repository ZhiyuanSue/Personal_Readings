# Introduction

我们目前有RTOS，也就是实时操作系统，用于支持时间敏感的系统

同时也有一些通用的操作系统（GPOS），用于支持一些丰富的功能

但是不巧的是，这两者并不能同时提供。因此，很多尝试试图同时满足两者



一种方法是，在RTOS中提供通用操作系统的完整的网络，通用图形界面，通常会损害实时性

另外，由于RTOS下的应用程序缺少工具链的支持，比如posix和GNU glibc，所以开发效率低下



同时，如果试图在linux这样的通用操作系统中，支持RTOS的实时性，也就是扩展linux，例如rt-linux，resource kernel for linux，time-sensitive linux。目前用的最多的是 PREEMPT-RT补丁扩展。他用一堆补丁，让linux的不可抢占的部分也变得可以抢占了。

但是，这个补丁也有问题

无法证明其具有硬实时的功能

是在上游代码树之外维护的，维护工作量巨大。



还有一种方法是和linux运行协同调度的RTOS，然后劫持中断请求

但是这样的方法有个缺点，必须将进程分开设计，在linux下的，和用于rtos的进程分开设计，他仍然无法使用丰富的linux环境



于是本文设计了一个复合的RTOS（cRTOS）



# System Design

## 设计目标

也就是把上面那些背景资料转换成实际的目标

- 短而有界限的抖动，从而满足硬实时的目标

- 对内核具有较好的可维护性，从而不需要修改内核

- 对应用具有良好的可用性，可以访问linux内核的丰富功能

## 具体实现

具体实现要看图1

他包括了两个领域，一个是normal realm，一个是real-time realm

在normal realm运行了一个GPOS——感觉就是linux，占用大部分硬件资源，包括处理器核心和非RT的硬件资源，每个核心还都有一个PIC中断控制器

在real-time realm运行了一个sRTOS（swift RTOS），他使用了一个专门设计的RTOS，提供硬实时环境，更短和更一致的中断环境，占用特定的处理器内核以及特定的实时硬件设备



关于两者的协作，通过VM之间的消息通信和shared memory实现



## 应用开发（应该主要指的是实时应用）

首先，在normal realm创建一个实时进程

然后这个进程在normal和real-time realm都可以被看见，作者称为rich real-time 进程

同样在图1中，可以看到这个进程被两个realm共同看见

对于rich real-time进程，他可能存在多个线程，在实时领域被调度执行，依赖于此，可以提供硬实时

同一个进程，在normal realm中还有一个对应的影子进程（shadow process）用于访问linux的丰富资源和特性，从而避免多个real-time进程访问同样的资源的时候的阻塞



具体应用开发过程

1、选择一个GPOS和sRTOS

GPOS选择Linux，而sRTOS则有一些限制，如果他没有实现多进程地址空间和其他的POSIX的特性的支持，则必须加以改造，还需要改造系统调用处理。这些实现后面会说

2、设计一个rich real-time process

需要考虑实时和非实时的线程，实时线程用于完成关键算法，非实时线程用于访问Linux的丰富特性，使用无锁算法来共享变量

3、在GPOS中设计开发和测试原型程序，这一步可以利用GPOS中丰富的特性解决前面提到的工具链不够丰富的问题

4、改造成sRTOS的过程中，有些实时的设备，并没有相应驱动，需要写这部分的驱动

5、验证实时性（好吧就是测试时间，WCET能满足）



# implement



# Handling System calls





# 性能

评价了一大堆，请自行看原文
