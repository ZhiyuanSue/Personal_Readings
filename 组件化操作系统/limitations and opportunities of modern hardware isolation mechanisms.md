# Introduction

大概是说，比如像x86这种弃用了分段机制

但是如果是基于页面的隔离的话，每个IO不过100周期，但是要花费700-800个周期在隔离的跨子系统调用上，作者认为这是难以接受的问题。



所以MPK，EPT和VMFUNC在现代intel cpu中被部署

而ARM实现了MTE实现了16字节的粒度的隔离（还有PAC指针签名的特性），英特尔实现了SPP支持128字节



ARM还设计了一个CHERI capability 模型，并且在ARM Morello上进行了实现。

MPK的缺点是，无法反应在系统所有核心之间的零拷贝区域的传递，所以其他核心难以访问。

以及重新标记存在问题。速度不够快。

总而言之都存在无法跨内核执行权限撤销



还有一个问题是编译器

就是说，编译器工具链中需要增加不少内容，这个开销太大了，难以接受（MPK和Morello挺好的，但ARM的MTE和PAC则不是）

应该支持跨核心的行为。只有MTE做到了

而且需要做到支持大量的数量，因此也需要频繁地撤销，而不是仅仅考虑建立隔离区域



# Background

过去很多OS都探索了模块隔离问题，但是商用OS基本上就没用到啥。

商用CPU也设计了一堆

MPK在单个地址空间内强制隔离，使用4bit的保护键标记页面

使用pkru保存位图

只有pkru的标记和页面的标记匹配的时候才可以读写



可以通过快速的更新pkru的位掩码即可实现

需要在编译器中控制所有的wrpkru

但是问题是在于他仅仅对数据访问检查，但是不限制控制流转换



ARM MTE

地址空间划分为16字节的区域，并且用16个标记中间的一个着色，只有指针的标签与内存区域的标签匹配，才允许访问。

攻击者可以改变指针上半部分，所以需要二进制编译的时候去对加载和存储实施特定的标记



PAC则更棒了，还支持了一个签名上下文，可以比如说在stack pointer相同的时候，才允许使用指针。



Morello我觉得跟SeL4的capability很像了。

什么capability的派生啦巴拉巴拉的



控制流强制技术（CET）



# Design principle for efficient isolation

目的就是服务链上互不信任的子系统之间提供隔离

传递语义

隔离机制还需要提供零拷贝机制

并且这个零拷贝需要快速的



# Isolation 机制设计

## 1、Intel MPK+CET

使用15个标签（0表示所有权限都允许）中的1个表示子系统的私有堆。

使用了一个MPK跳板页

使用CET来保护跳板页



## 2、ARM MTE

因为保存在指针的上半部分，所以可以溢出指针数值进行攻击，所以需要强制的用bfi指令从保留寄存器复制到地址寄存器

但是对于堆栈指针指向的地方，不执行MTE检查。

## 3、ARM PAC

## 4、ARM morello

看上去是在每个指针解引用，即加载和存储指令上实现硬件边界检查。

我觉得我没看懂这个。