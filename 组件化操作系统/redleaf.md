# redleaf

## Introduction

使用rust语言本身的机制而不是硬件隔离机制，进行隔离

硬件和软件都试图做了很多操作来进行隔离

安全的语言试图做垃圾收集，但是会存在性能问题。

除了使用rust的所有权规则之外，也要看到rust在故障隔离，透明的设备驱动程序恢复，



## 隔离错误

需要提供一种机制，让他在如果发生了错误的时候，

1、释放子系统正在使用的所有资源

2、保留需要这个子系统分配并随后需要传递的其他资源

3、对于释放掉的子系统的接口，在重启之前，都会返回一个错误。



## 过去的工作

堆隔离的思想

线性类型

Sing# 语言和操作系统的结合

Netbricks和Splinter

Tock 硬件隔离加上受限的系统调用接口



## 隔离的原则

1. 堆隔离，就是指针这件事，不持有任何指向其他域的指针，从而直接释放掉整个堆是安全的，但是又留了一个全局的堆用于交换
2. 可交换类型，可以跨域安全交换的类型，强制分配在共享堆上面，不会有指向私有域的指针，可以引用在共享堆上面的其他的对象。
3. 所有权跟踪，如果一个模块挂了，那么通过所有权跟踪，来决定在共享堆上面的东西是否释放掉。
4. 跨域接口强制使用可交换类型。
5. 代理层，所有接口上用的，如果这个模块挂了，由这个代理来搞定返回一个错误值。

为了验证，还开发了一种接口定义语言，IDL

（精妙的设计哈）

设计为微内核



## 基于语言的隔离

J-kernel和KaffeOS

指出语言本身并不足以支持强制故障隔离和终止不可信子系统的

J-kernel目的是JAVA，感觉做了类似于本文的工作，但是没有做IDL的静态的检查，而是封装了一个对象

KaffeOS则做了一个写屏障

验证指针赋值

提出了类似于本文的一个堆隔离和私有域的东西



都需要深度复制

Singularity OS，强制单一所有权，即一次只能有一个域对共享堆上面的东西存在所有权。

他基于那个sing#语言，就是所有权从一个域转移到另一个域



RedLeaf使用迁移线程模型来完成微内核的远程过程调用



## 迁移线程模型

服务器线程就更多是一个代码仓库，而不是把RPC传送数据到服务端，而是用户使用自己的资源执行服务器的代码。这可以很大程度上的提升IPC性能。



# RedLeaf Architecture

整体结构大概就是作者这个图里面所说的那样

微内核架构，但是都跑在ring 0，但是，微内核和可信库之外的所有域的代码都必须是safe的rust

使用trusted proxy进行跨域通信，在迁移线程过程中，需要检查该域是否还活着



## 故障隔离

当进入该域的一个线程出现问题，认为域崩溃，需要终止

步骤如下

1、将崩溃域里面的线程unwind到入口点（不明白），并返回调用者一个错误。

2、对于之后试图调用崩溃域的一个调用会返回错误，但是并不会导致panic

3、释放崩溃域的资源

4、对于在域崩溃之前移出去的其他资源，可以由其他资源继续访问



大的内容我看懂了，但是实在是没琢磨明白



## 私有域和共享域

新的RRef< T >类型

两级内存方案

就是说，微内核只提供大的粒度的内存分配，然后细粒度的内存分配器由本身域中的内存分配器来管理。

这样，微内核可以以很小的代价记录私有域分配的情况

至于崩溃了，直接把整个域这些大粒度的内存页全都释放掉。



## 可交换类型

作者定义了一些可交换类型

## 所有权跟踪

在RRef类型中有个指向所有权的域

如果是跨域调用中被不可变的借用，则不会更改指向的域，而是会增加引用计数



对于RRef的递归引用

只有根具有对应的域id



另外还有一个proxy的全局注册表用于记录所有的这些共享对象。



## Proxy代理

做以下工作

调用接口的时候检查域是否活跃，如果活跃，在微内核中记录更新状态。

当崩溃的时候会把这些线程都处理好（unwind，这到底是干嘛呢）

其他巴拉巴拉对可交换类型等等东西做一个更改



主要是加了一个汇编的跳板

在线程进入域之前就做了一个保存记录

保存所有的通用寄存器

微内核为所有的线程，每个都做了一个延续堆栈

以及在堆栈里面放了一个错误处理函数，这个错误处理函数和接口同名

因此，如果寄了，就会转到这个错误处理函数执行（我感觉相当于把这个返回地址压栈）



对于返回类型，反正要求错误处理函数和接口函数都返回RpcResult< T >



## 动态域加载

域独立于内核并动态加载



## RV6操作系统

嗯，感觉就是个上面的想法的一个实现。反正，总而言之，非常棒的一些设计。