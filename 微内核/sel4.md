# Before start
这是我用于记录阅读sel4相关内容的笔记，但愿能尽量看完吧。
我先看的是一个中文的文档
代码还没动手读

## 简介
约8700行C就能实现，嗯，挺好

## 内核服务和对象
内核支持的服务
线程，调度上下文，地址空间，进程间IPC（但是实际上没有进程概念），回复对象（用于存储一次性使用的回复能力）
通知，一种两值信号非阻塞发射机制
设备抽象，将驱动作为一个非特权的应用程序，通过IPC实现传递设备抽象
能力空间，Capability Spaces


MCS Mixed Criticality System 混合关键系统，一种硬实时系统

### Capability访问控制

相当于一个访问控制。
每个应用程序都有一个能力空间 Capability space，每个地址都指向一个slot，表明包含或者不包含一个能力。

Capability被实现为一个Cnodes有向图，Cnode表示为一个能力节点
一个CNode是一个slot表，每个Slot可以包含其他的Cnode

能力可以在能力空间内复制或者移动，或者通过IPC发送。
这允许能力的一种委托。也就是把某个内核服务的能力赋值给其他应用程序。

或者可以生成。
只能减少不能增加。

可以撤销。递归的从派生出来的所有能力中删除。

能力的传播基于take-grant模型控制。

### 系统调用
线程通过使用capacity space的能力，去发送消息。如果引用一个端点，通知或者回复能力，消息将通过内核传递到其他线程。
如果引用其他内核对象的能力，将被解释为方法调用。

（所以说到底都是Capability调用）

可以认为内核提供了三个系统调用
send
receive
Yield

一些变体也被提供，比如call，包含一个send，一个receive，也就是等待一个reply

通过特殊的资源进行消息的回复，而不是标准的IPC

调用端点和通知之外的内核对象的方法，需要使用Send和call

Yield不需要任何能力的内核操作。

Send会阻塞直到消息可以交付

Recv会阻塞直到有消息可以发送

组合和变体

seL4 NBSend 端点上执行轮询发送。如果没有接受的线程，会被静默丢弃。
相当于没有阻塞的发送

seL4 NBRecv 用于非阻塞的接收通知对象挂起信号或者端点上等待发送的消息

seL4 Call前面说了相当于Call和Recv的混合

seL4 Reply 响应seL4 Call

seL4 ReplyRecv

### 内核对象

1、Cnodes
有固定数量slot，通常是2的幂，在CNode创建时确定的。

2、TCB
字面意思

3、调度上下文
SchedulingContexts
额，我觉得按照他这个说法，可能不是我所理解的上下文
他说是CPU时间。
可以从未分配内存中创建调度上下文。
可以用优先级来控制CPU的访问时间。

4、端点
用于在两个线程之间传递消息，这是同步的。

5、回复对象
提供一次性使用的回复能力容器。

6、通知对象
感觉相当于一个简单的锁

7、虚拟地址空间对象
用于为一个或者多个线程构造虚拟地址空间
额，他竟然加入了ASID，emmm不懂有啥用

8、中断对象
给应用程序接收和应答硬件中断的能力
一开始有一个IRQControl能力，允许创建IRQHandler，每个管理一个与特定设备相关联的特定中断源并委托给一个设备驱动程序

然后允许线程等待并应答单个中断

9、未分配内存
只有一个单一的方法，创建新的内核对象
