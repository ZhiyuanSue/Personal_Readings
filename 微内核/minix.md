# introduction
对于系统调用，
进程管理。信号。文件系统。文件系统目录管理。用户权限保护。时间管理。
我不理解为什么一定要有文件系统的syscall，但是进程，信号，权限，时间，我认为这是必须的。

brk和sbrk
他说这不是posix标准的内容。
还有关于进程组。额我理解这种分组进行权限管理，以及资源分配的事情
但是如果单纯实现一个微内核，我认为这种分组也并不是必须的（当然，你要是分组，是为了将内核服务的线程分为一个组，当我没说）

信号
需要注册一个信号处理函数，以处理相应的信号
然后如果收到信号，就会对应的调用相应注册的函数。

真实uid和有效uid
minix还是比较经典的改成了进程管理，io设备管理，存储管理和文件管理

再生服务器：
负责启动或者重启驱动和服务，最开始被阻塞，等待消息告诉他创建什么。这个消息应该来源于init进程创建的shell脚本。
我觉得这应该是一个重要的组件。

内核级线程和用户级线程
用户级线程看上去更好，但是，问题在于，由于内核感知不到线程的存在，存在一些同步的问题。

对于用户线程和内核线程的调度问题。

minix的四层结构，潜在的认为上面三层都有一定的特权，第三层可以访问一定的IO端口，而第四层没有特权。

daemon守护进程

时钟任务比较特殊
对于内核进程的时钟任务和用户态的时钟任务不太一样

但我好奇，vdso不能用在这这里么。

init进程运行之前，就有一些系统进程在运行了，并没有PID，也不在进程树中。

init作为再生服务器的一个子进程

他这里面进程数量少，所以加了一个notify机制。我觉得类似于sel4的通信原语。

但他用了一个奇奇怪怪的位图，我只是好奇一个事情，他这个位图在进程数量太多的情况下会怎样。

中断问题
主要就是把中断转换成消息并隐藏。

消息类型的格式。


存储管理，他缺少完整的存储管理，存储管理是放在进程管理子进程中使用的。


使用的intel特权级的问题。
他使用了三个特权级，ring1 被用于一些系统进程的实现。

进程聚合 rendezvous
检查目标进程是否等待任意发送者的消息，如果是，则复制消息。
然后这两个进程都变成就绪态。

如果没有等待消息，则会标记为阻塞。

哦，如果双方相互发消息，会有可能引起死锁。

需要检测这件事情。

是否阻塞在接接收，并且问他在等谁。

我觉得这个IPC模块应该是另一个需要考虑的模块。
而且他的很多操作依赖于进程控制相关内容。

对于除了时钟任务之外的中断处理
会注册入一个generic handler的地址，他会通过中断位图判断增加一个向对应进程的通知。

另一个相关的策略是，在handler函数结束之后，需要判断是否马上打开，还是继续关闭。
后者需要向系统调用发消息，弄一个irqenable

idle task
他有个hlt，这是运行在内核态的指令，按道理不应该允许用户态执行。
需要level0的一个区域

提供了一个系统任务进程，这个进程是专门用来实际和IO等敏感指令打交道的
用户相关的进程实际上和这个进程通信，然后再和硬件进行IO

系统任务会接收一堆消息。

