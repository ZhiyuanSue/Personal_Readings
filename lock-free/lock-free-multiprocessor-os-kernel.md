# introduction
在多处理器中的互斥可以通过等待锁和自旋锁实现。

首先是说CAS比TAS更好一些

他实现了一个Synthesis的无锁操作系统
揭示了三件事情
无锁对于多核的现代操作系统，包括线程，虚拟内存，都是可行并且足够了的
其次，是实用的
第三，实现了比较高的性能

# 操作系统内核同步
有三个基本的同步问题：
硬件中断
软件中断和临界区

在单处理器中，所有这些问题可以廉价的禁用硬件中断解决，所以这玩意的使用非常广泛，因为就两条指令，非常快
但是需要注意不能太长，还有多cpu就没啥用了

禁用信号更复杂，必须测试当前是否允许该信号，所以在临界区结束之后，必须测试并且执行所有挂起的信号。
更糟糕的事情是，禁用信号如果在预期的事情没有发生的时候，会导致进程卡住

锁定同步的方法
mutual exlusion可以通过锁定来一次只允许一个进入临界区，包括忙碌等待和阻塞。

spin lock主要的问题在于浪费时间，因为多个线程映射到同一个物理处理器的时候，就是盲等直到时钟信号给你切走

锁的争用会导致性能下降，还有死锁，以及优先级翻转问题。

## 无锁同步的方法

CAS是无锁同步的基础
定义，wait-free如果保证进程在一定数量的操作中能够完成一个操作，那就是wait-free

herlihy的方法是，将整个堆栈切换到新的指向该堆栈的指针，这里用了copy
所以成本比较高

这个os的算法是这样的，首先是试图压缩成一两个word，如果可以，直接CAS，否则封装在一个已经设计好的无锁对象中，包括LIFO的stack，一个FIFO的队列，一个通用的linked list

如果保持数据一致性，他用一个乐观策略
他给每个线程一个word，彼此不同，然后试图进入临界区，结束后查看系统状态编码是否改过了，如果改过了，说明有其他线程进入，所以需要重新试一遍。

还试图降低每个临界区的长度，在长的临界区中间加一个一致性状态点，分成两个更短的

将数据封装在只有该临界区知道的临时无锁对象中。

第三种方法是，代码隔离，即只有专门的代码处理数据操作。

一个案例是run-queue通常是用信号量和自旋锁保护的
这里的做法是，只有位于每个元素中的代码才能更改他。
因此，在这里，分开了，无锁的遍历队列元素和队列元素更新，分开。

# 三个无锁对象
LIFO的栈
对于Stack 的pop，和计数器增量的实现类似，将堆栈指针当前值读入一个私有变量，解引用，获得栈顶，并且使用CAS来监测变动，如果是stack push，更加复杂一些，需要两个word的比较与交换（DCAS），需要将当前的指针读入一个私有变量，递减（我的理解是，增加一个栈的值，因为栈向下生长），结果放入私有变量，测试堆栈指针是否没有改变，并存入新值以及新的栈顶元素

FIFO的队列
使用乐观同步的FIFO的实现，FIFO支持两种主要操作，Q_put和Q_get
Q_full和Q_empty处理边界条件。队列元素可以是每次一个字节，每次一个long word，每次一个字节流。此外，字节流类型还支持任意大小的数据块元素。

程序员可以选择不同的生产者消费者模型来使用队列，单个生产者消费者，单个生产者多个消费者。。。总共四种

通用链表
通用链表的操作相对更为复杂，但是这并非一定是最优的，可以看别的专门对这件事情做研究的paper

## 线程调度的实现
v0只有一个运行队列，包含所有的线程。
v1则有多个运行队列。
单队列无需多说，使用上面的无锁的链表的设计，就行

对于多个队列，使用8个级别的队列，用8个TTE表示

每个级别的占用的cpu时间呈指数下降，具体来说，第一个级别占用一半的cpu时间
其他占用剩下的一半
如果确实没有多余的cpu需要，可以扔给下一个队列
他用了一个优先级表，来进行调度多个队列，比如每隔一项有个0，每4项有个1，巴拉巴拉。

对于多个cpu，通过CAS去试图获得一个新的TTE，如果能够成功，那么就拿到了该队列，否则，就是应该尝试下一个TTE表示的队列。


## 线程操作

总体还是一样的，执行操作，查看情况是否有变化，如果为负数，则结束操作（我有点怀疑），都通过比较与交换来完成的。

然后列举了各种操作
反正看了之后，额，上面的思路就是他的思路

# 虚拟内存操作
pmm的管理，使用上面说的链表操作，只需要在头部插入就行（也许）
虚拟内存的管理，从逻辑上，也是如此，仅仅是查看是否有bit位的占用。

总结
我感觉思路简单，理论上可行。

但是，这真的是无锁的算法么？？？我有点怀疑
因为这么做跟自旋锁没啥差别。
