# introduction
在多处理器中的互斥可以通过等待锁和自旋锁实现。

首先是说CAS比TAS更好一些

他实现了一个Synthesis的无锁操作系统
揭示了三件事情
无锁对于多核的现代操作系统，包括线程，虚拟内存，都是可行并且足够了的
其次，是实用的
第三，实现了比较高的性能

# 操作系统内核同步
有三个基本的同步问题：
硬件中断
软件中断和临界区

在单处理器中，所有这些问题可以廉价的禁用硬件中断解决，所以这玩意的使用非常广泛，因为就两条指令，非常快
但是需要注意不能太长，还有多cpu就没啥用了

禁用信号更复杂，必须测试当前是否允许该信号，所以在临界区结束之后，必须测试并且执行所有挂起的信号。
更糟糕的事情是，禁用信号如果在预期的事情没有发生的时候，会导致进程卡住

锁定同步的方法
mutual exlusion可以通过锁定来一次只允许一个进入临界区，包括忙碌等待和阻塞。

spin lock主要的问题在于浪费时间，因为多个线程映射到同一个物理处理器的时候，就是盲等直到时钟信号给你切走

锁的争用会导致性能下降，还有死锁，以及优先级翻转问题。

## 无锁同步的方法

CAS是无锁同步的基础
定义，wait-free如果保证进程在一定数量的操作中能够完成一个操作，那就是wait-free

herlihy的方法是，将整个堆栈切换到新的指向该堆栈的指针，这里用了copy
所以成本比较高

这个os的算法是这样的，首先是试图压缩成一两个word，如果可以，直接CAS，否则封装在一个已经设计好的无锁对象中，包括LIFO的stack，一个FIFO的队列，一个通用的linked list

如果保持数据一致性，他用一个乐观策略
他给每个线程一个word，彼此不同，然后试图进入临界区，结束后查看系统状态编码是否改过了，如果改过了，说明有其他线程进入，所以需要重新试一遍。

还试图降低每个临界区的长度，在长的临界区中间加一个一致性状态点，分成两个更短的

将数据封装在只有该临界区知道的临时无锁对象中。

第三种方法是，代码隔离，即只有专门的代码处理数据操作。

一个案例是run-queue通常是用信号量和自旋锁保护的
这里的做法是，只有位于每个元素中的代码才能更改他。
因此，在这里，分开了，无锁的遍历队列元素和队列元素更新，分开。

# 三个无锁对象
LIFO的栈

