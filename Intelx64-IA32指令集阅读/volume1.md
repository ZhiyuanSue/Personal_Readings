# 1、各种表示法

Bit和Bytes顺序

保留位



使用Byte地址

多个Segments



CPUID指令

# 2架构相关

### P6架构

3发射超标量，12阶段流水线

乱序执行

深度分支预测

动态数据流分析

预测执行



### NetBurst架构

高速执行引擎

超流水线技术

高级动态执行

增强的分支预测技术

新的cache子系统

感觉从图上看就多个了三级cache

简单来说包含三个部分：前端，乱序执行，retirement



前端包括

预取

fetch

decode

生成微码

分发

预测



影响前端delay的因素有：

解码速度

分支目标导致的解码带宽的浪费

用指令预取搞定的



乱序单元



retirement 单元



### Core架构

主要说一个之前不知道的

macro fusion和micro fusion

micro fusion，就是随着分解为微操作，会导致在寄存器重命名和retirement阶段有很大的性能瓶颈

做的事情就是，原先一条指令会被分解成为多个微操作，去占用ROB，但是现在合并，在rename阶段合并，然后和之前一样发送给EU，从而去降低这个rename阶段的瓶颈

macro fusion

比如cmp或者test之后然后跳转，而不仅限于之前分解为微操作的单条指令中的多个微操作。



具体架构见那张图，对于EU则有多个EU



### Atom

差不多



### Nehalem

加了什么power管理什么的

哎呀，总之那些说的好听的，无非是数量啥的问题，影响不大



### SIMD指令相关

MMX，SSE，SSE2，SSE3，SSE4



### Intel 超线程技术HT

反正每个核心多增加了一批状态寄存器APIC什么的东西

但是执行单元还是这些（不过说真的，这个设计确实会提升性能挺大）



启用逻辑处理器和启用MP系统的处理器一样



### 多核技术

唔，没啥值得记录的



### Intel 64架构

增加了地址空间

增加了IA-32e模式

这个IA-32e模式允许32位软件无修改的运行，以及允许了64位os跑64位的地址空间

包括64位扁平的地址空间

8个额外的通用寄存器

8个额外的SIMD寄存器

64位通用寄存器和指令指针

统一编码空间

快速中断优先机制

一种新的指令指针相对寻址模式



### VT（具体见我对于Intel虚拟化的记录）



# 3、基本执行环境

IA-32有三种模式

保护模式，其中包括虚拟8086模式，这是保护模式的一个属性

实模式，上电后处于实模式

**系统管理模式（SMM）**。此模式为操作系统或者执行程序提供透明的机制，用于实现特定的功能，比如电源管理和系统安全。当SMI引脚中断被激活或者APIC接收到SMI中断时，处理器进入SMM模式。

在SMM中，处理器切换到单独的地址空间，同时保存上下文，透明的执行SMM特定的代码，



Intel 64添加了一种IA-32e模式。这有两种子模式

兼容模式

唔，其他差不多，有两个说法需要注意，一个是没法跑virtual 8086模式的或者使用硬件任务管理的

和32位保护模式差不多。只能访问4GB线性空间。



### 基本执行环境包括

地址空间，在IA32上面有一个4GB的线性地址空间，以及最高2的36位的64GB的物理地址空间。

基本寄存器。8个通用寄存器，6个段寄存器，EFLAGS寄存器，EIP

XMM寄存器

YMM寄存器

BND（没听说过）

stack

控制寄存器，比如CR0-8

Debug寄存器

描述符表寄存器 GDTR IDTR LDTR和TR



## 关于内存组织

物理内存在不支持64bit的架构上，最多到2^36-1



### IA-32内存模型

不直接使用物理内存，而是三种模式: flat,segmented和real address mode

Flat：线性地址空间，大概也就2^32-1

Segmented：代码段数据段还有堆栈段，都在独立的段中，称为逻辑地址空间，使用一个段选择子加上一个偏移。最多可以有16383个段，每个段可以访问到2^32bytes的空间。但是这个段空间还是会映射到一个线性空间中去，

Real-address mode：专门用于8086的



使用flat或者segmented内存模型的情况下，线性地址会通过直接映射或者通过分页的方式来进行映射到物理地址。

直接映射的情况下，线性地址会一对一映射到物理地址上。

使用分页机制的时候，线性地址会使用分页机制映射到对应的地址上去。

除此之外，还有两个东西：

#### PAE

physical address extension来处理超过4GB的空间

#### PSE

Page size Extension将其映射到4Mb的大页上面

简单来说，在虚拟这边，段方式和直接映射方式获得一个线性地址，线性地址再通过直接映射或者分页映射方式获得一个物理地址。

### 64Bit模式下的内存组织

线性地址是通过PAE分页方式来映射到物理地址的



### 关于内存模型和操作模型的事情

保护模式，可以使用任何地址模式，实模式的地址，只有在虚拟8086才有用，当多任务开启的时候，可以使用不同的内存模型

实模式，只有实地址模式可以用

SMM模式，转换到一个system management RAM SMRAM，更像 一个实地址模式

兼容模式，和32位保护模式差不多

64位模式，段式寻址已经禁用（但不完全），处理器认为CS，DS，ES以及SS都是0。分段和实模式在64位模式下是不可用的



### 操作码

32位模式下，使用16位段选择子和32位偏移，使用16bit地址模式，16位段选择子和16位偏移。



### PAE

将4g空间，映射到64g物理地址空间去。

### 64位模式下的地址计算

在大多数情况下，64 位模式对代码、数据和堆栈使用平面地址空间。在 64 位模式下（如果没有地址大小覆盖），有效地址计算的大小为 64 位。有效地址计算使用 64 位基数和索引寄存器，并将符号扩展位移设置为 64 位。



因为CS，DS，ES和SS都被认为是0，所以剩下FS和GS都不是0，如果这俩设为0，那么线性地址等于有效地址。如果这俩不是0，有效地址会先截断然后加上段基地址。基地址则从不截断，和64位模式下的地址模式无关。

EIP变成了RIP。

通常来说，64位模式下的displacements和立即数不会扩展为64位，他们仍然会限制在32位，并且在有效地址计算的时候使用符号扩展。但是mov指令提供了64位的displacement和立即数形式

在IA-32e模式下16和32位的地址计算都是0扩展的，因此结果会0扩展为64位的地址，从而导致只能访问低4GB空间。



### 规范寻址

通常来说，64位地址是64位，但是在实现中，并不会用到这么多，比如最早的支持64位模式的实际只支持48位的线性地址，那么高位必须全0或者全1（这依赖于47位是0或者1）

如果该地址不是规范地址的形式，会生成一个例外，通常情况下是一个general-protection例外（GP）但是如果是stack，那么会是一个(SS)stack fault的错误



默认情况下使用SS段寄存器表示段基址，从而PUSH POP相关的指令都用RSP RBP作为基寄存器。

如果使用一个非SS的段，通过段覆写的方式则是会生成一个GP，在64位模式下，只有FS和GS可以搞什么段覆盖，其他的则会被忽略。这意味着，SS段覆写也是失效的。仍然会生成一个GP

（md这段我没看懂）



### 基本编程的寄存器

1、通用寄存器，EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP，通常ESP作为堆栈指针不会动（EBP感觉也是哈。。。）有些指令比如串传送，会使用ECX，ESI，EDI作为操作数。

- EAX通常作为操作数和结果寄存器

- EBX通常作为DS段的指针

- ECX通常计数

- EDX通常作为I/O指针

- DS：ESI和ES:EDI，串的源和目的指针，ESP堆栈指针，EBP

在64位模式下，32位的操作数情况下，除了上面几个，还指定了R8D-R15D这额外8个寄存器。如果是64位操作数的情况下，RAX，RBX，RCX，RDX，RDI，RSI，RBP，RSP，R8-R15

仅仅在64位模式下有的寄存器R8-R15以及XMM8-XMM15，在转换为兼容模式下，还是一样的定义，但是转换到保护模式或者实模式就未定义了。

在64位模式下，

8位寄存器为

AL，BL，CL，DL，DIL，SIL，BPL，SPL，R8L-R15L。没有什么AH巴拉巴拉了

16位寄存器，其他正常，R8W-R15W，

感觉就是L,W,D。

在64位模式下，不可以同时访问AH，BH，CH，DH，和RAX这样的扩展寄存器（因为前面那个使用兼容模式做的），对这几个的访问会强制变为BPL，SPL，DIL，SIL。

在64位模式下，64位直接用，32位的操作数生成的结果会通过0扩展变成64位，但是对于8和16位那么则不改变其他位，要改就进行符号位扩展。

如果从64位转换到32位（包括兼容模式），高32位地址是没法保存的，软件不应当依赖这个。

2、段寄存器

32位模式下，在flat模式下，所有段寄存器都是为0，在分段则不是

每个段寄存器包括三种模式，code，data，或者stack

CS段表示的是code，DS，ES，FS和GS是data，SS是stack，可以被显式的load（我觉得这个意思是对于应用程序员而言），FS和GS是IA-32架构引入的。

在64位模式下，四个都是0，FS和GS是额外的，这几个寄存器会用于计算线性地址。

虽然这几个寄存器没用了。但是仍然在检查中是重要的，因为他有可能用于兼容模式。

这些检查显然会包括一些比如说，权限等等。

3、EFLAGS

状态flag：bit0-cf，bit2-pf（结果最低位的有效字节包含偶数位1位，则设置，否则清除），bit4-Auxiliary carry flag（BCD码的借位），bit6-ZF，bit7-SF，bit11-OF，只有CF位可以直接改，使用STC，CLC和CMC指令，（CMC指令是取反的意思），

4、EIP


