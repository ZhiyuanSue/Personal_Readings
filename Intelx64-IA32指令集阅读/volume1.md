这不是给人看的，这是给自己看的，所以只整理我不知道的部分

# 1、各种表示法

Bit和Bytes顺序

保留位



使用Byte地址

多个Segments



CPUID指令

# 2架构相关

### P6架构

3发射超标量，12阶段流水线

乱序执行

深度分支预测

动态数据流分析

预测执行



### NetBurst架构

高速执行引擎

超流水线技术

高级动态执行

增强的分支预测技术

新的cache子系统

感觉从图上看就多个了三级cache

简单来说包含三个部分：前端，乱序执行，retirement



前端包括

预取

fetch

decode

生成微码

分发

预测



影响前端delay的因素有：

解码速度

分支目标导致的解码带宽的浪费

用指令预取搞定的



乱序单元



retirement 单元



### Core架构

主要说一个之前不知道的

macro fusion和micro fusion

micro fusion，就是随着分解为微操作，会导致在寄存器重命名和retirement阶段有很大的性能瓶颈

做的事情就是，原先一条指令会被分解成为多个微操作，去占用ROB，但是现在合并，在rename阶段合并，然后和之前一样发送给EU，从而去降低这个rename阶段的瓶颈

macro fusion

比如cmp或者test之后然后跳转，而不仅限于之前分解为微操作的单条指令中的多个微操作。



具体架构见那张图，对于EU则有多个EU



### Atom

差不多



### Nehalem

加了什么power管理什么的

哎呀，总之那些说的好听的，无非是数量啥的问题，影响不大



### SIMD指令相关

MMX，SSE，SSE2，SSE3，SSE4



### Intel 超线程技术HT

反正每个核心多增加了一批状态寄存器APIC什么的东西

但是执行单元还是这些（不过说真的，这个设计确实会提升性能挺大）



启用逻辑处理器和启用MP系统的处理器一样



### 多核技术

唔，没啥值得记录的



### Intel 64架构

增加了地址空间

增加了IA-32e模式

这个IA-32e模式允许32位软件无修改的运行，以及允许了64位os跑64位的地址空间

包括64位扁平的地址空间

8个额外的通用寄存器

8个额外的SIMD寄存器

64位通用寄存器和指令指针

统一编码空间

快速中断优先机制

一种新的指令指针相对寻址模式



### VT（具体见我对于Intel虚拟化的记录）



# 3、基本执行环境

IA-32有三种模式

保护模式，其中包括虚拟8086模式，这是保护模式的一个属性

实模式，上电后处于实模式

**系统管理模式（SMM）**。此模式为操作系统或者执行程序提供透明的机制，用于实现特定的功能，比如电源管理和系统安全。当SMI引脚中断被激活或者APIC接收到SMI中断时，处理器进入SMM模式。

在SMM中，处理器切换到单独的地址空间，同时保存上下文，透明的执行SMM特定的代码，



Intel 64添加了一种IA-32e模式。这有两种子模式

兼容模式

唔，其他差不多，有两个说法需要注意，一个是没法跑virtual 8086模式的或者使用硬件任务管理的

和32位保护模式差不多。只能访问4GB线性空间。



### 基本执行环境包括

地址空间，在IA32上面有一个4GB的线性地址空间，以及最高2的36位的64GB的物理地址空间。

基本寄存器。8个通用寄存器，6个段寄存器，EFLAGS寄存器，EIP

XMM寄存器

YMM寄存器

BND（没听说过）

stack

控制寄存器，比如CR0-8

Debug寄存器

描述符表寄存器 GDTR IDTR LDTR和TR



## 关于内存组织

物理内存在不支持64bit的架构上，最多到2^36-1



### IA-32内存模型

不直接使用物理内存，而是三种模式: flat,segmented和real address mode

Flat：线性地址空间，大概也就2^32-1

Segmented：代码段数据段还有堆栈段，都在独立的段中，称为逻辑地址空间，使用一个段选择子加上一个偏移。最多可以有16383个段，每个段可以访问到2^32bytes的空间。但是这个段空间还是会映射到一个线性空间中去，

Real-address mode：专门用于8086的



使用flat或者segmented内存模型的情况下，线性地址会通过直接映射或者通过分页的方式来进行映射到物理地址。

直接映射的情况下，线性地址会一对一映射到物理地址上。

使用分页机制的时候，线性地址会使用分页机制映射到对应的地址上去。

除此之外，还有两个东西：

#### PAE

physical address extension来处理超过4GB的空间

#### PSE

Page size Extension将其映射到4Mb的大页上面

简单来说，在虚拟这边，段方式和直接映射方式获得一个线性地址，线性地址再通过直接映射或者分页映射方式获得一个物理地址。

### 64Bit模式下的内存组织

线性地址是通过PAE分页方式来映射到物理地址的



### 关于内存模型和操作模型的事情

保护模式，可以使用任何地址模式，实模式的地址，只有在虚拟8086才有用，当多任务开启的时候，可以使用不同的内存模型

实模式，只有实地址模式可以用

SMM模式，转换到一个system management RAM SMRAM，更像 一个实地址模式

兼容模式，和32位保护模式差不多

64位模式，段式寻址已经禁用（但不完全），处理器认为CS，DS，ES以及SS都是0。分段和实模式在64位模式下是不可用的



### 操作码

32位模式下，使用16位段选择子和32位偏移，使用16bit地址模式，16位段选择子和16位偏移。



### PAE

将4g空间，映射到64g物理地址空间去。

### 64位模式下的地址计算

在大多数情况下，64 位模式对代码、数据和堆栈使用平面地址空间。在 64 位模式下（如果没有地址大小覆盖），有效地址计算的大小为 64 位。有效地址计算使用 64 位基数和索引寄存器，并将符号扩展位移设置为 64 位。



因为CS，DS，ES和SS都被认为是0，所以剩下FS和GS都不是0，如果这俩设为0，那么线性地址等于有效地址。如果这俩不是0，有效地址会先截断然后加上段基地址。基地址则从不截断，和64位模式下的地址模式无关。

EIP变成了RIP。

通常来说，64位模式下的displacements和立即数不会扩展为64位，他们仍然会限制在32位，并且在有效地址计算的时候使用符号扩展。但是mov指令提供了64位的displacement和立即数形式

在IA-32e模式下16和32位的地址计算都是0扩展的，因此结果会0扩展为64位的地址，从而导致只能访问低4GB空间。



### 规范寻址

通常来说，64位地址是64位，但是在实现中，并不会用到这么多，比如最早的支持64位模式的实际只支持48位的线性地址，那么高位必须全0或者全1（这依赖于47位是0或者1）

如果该地址不是规范地址的形式，会生成一个例外，通常情况下是一个general-protection例外（GP）但是如果是stack，那么会是一个(SS)stack fault的错误



默认情况下使用SS段寄存器表示段基址，从而PUSH POP相关的指令都用RSP RBP作为基寄存器。

如果使用一个非SS的段，通过段覆写的方式则是会生成一个GP，在64位模式下，只有FS和GS可以搞什么段覆盖，其他的则会被忽略。这意味着，SS段覆写也是失效的。仍然会生成一个GP

（md这段我没看懂）



### 基本编程的寄存器

1、通用寄存器，EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP，通常ESP作为堆栈指针不会动（EBP感觉也是哈。。。）有些指令比如串传送，会使用ECX，ESI，EDI作为操作数。

- EAX通常作为操作数和结果寄存器

- EBX通常作为DS段的指针

- ECX通常计数

- EDX通常作为I/O指针

- DS：ESI和ES:EDI，串的源和目的指针，ESP堆栈指针，EBP

在64位模式下，32位的操作数情况下，除了上面几个，还指定了R8D-R15D这额外8个寄存器。如果是64位操作数的情况下，RAX，RBX，RCX，RDX，RDI，RSI，RBP，RSP，R8-R15

仅仅在64位模式下有的寄存器R8-R15以及XMM8-XMM15，在转换为兼容模式下，还是一样的定义，但是转换到保护模式或者实模式就未定义了。

在64位模式下，

8位寄存器为

AL，BL，CL，DL，DIL，SIL，BPL，SPL，R8L-R15L。没有什么AH巴拉巴拉了

16位寄存器，其他正常，R8W-R15W，

感觉就是L,W,D。

在64位模式下，不可以同时访问AH，BH，CH，DH，和RAX这样的扩展寄存器（因为前面那个使用兼容模式做的），对这几个的访问会强制变为BPL，SPL，DIL，SIL。

在64位模式下，64位直接用，32位的操作数生成的结果会通过0扩展变成64位，但是对于8和16位那么则不改变其他位，要改就进行符号位扩展。

如果从64位转换到32位（包括兼容模式），高32位地址是没法保存的，软件不应当依赖这个。

2、段寄存器

32位模式下，在flat模式下，所有段寄存器都是为0，在分段则不是

每个段寄存器包括三种模式，code，data，或者stack

CS段表示的是code，DS，ES，FS和GS是data，SS是stack，可以被显式的load（我觉得这个意思是对于应用程序员而言），FS和GS是IA-32架构引入的。

在64位模式下，四个都是0，FS和GS是额外的，这几个寄存器会用于计算线性地址。

虽然这几个寄存器没用了。但是仍然在检查中是重要的，因为他有可能用于兼容模式。

这些检查显然会包括一些比如说，权限等等。

3、EFLAGS

- 状态flag：bit0-cf，bit2-pf（结果最低位的有效字节包含偶数位1位，则设置，否则清除），bit4-Auxiliary carry flag（BCD码的借位），bit6-ZF，bit7-SF，bit11-OF，只有CF位可以直接改，使用STC，CLC和CMC指令，（CMC指令是取反的意思），使用BT，BTS，BTR和BTC。

- DF状态位

bit10-DF，设置方向，置位之后，传送则自动减一

STD，CLD指令设置并且清理DF位。

- 系统flag和IOPL field

这些不应当被用户程序更改。

bit8-TF（trap flag，允许单步跟踪），bit9-IF（中断允许位），bit 12和13-IOPL，bit14-Nested task flag（控制任务连接到先前的任务），bit16-Resume flag（控制处理器对于debug例外的反应），bit17-Virtual 8086模式位，bit18-这个位有两个意思，Alignment检查位或者access ctrl位，当CR4里面的SMAP被置位，并且这一位为1，那么supervisor-mode下可以访问user-mode的页面，bit19-virtual interrupt flag（同样跟虚拟机有关），bit-20，指示中断挂起，和VIF位一起用，bit-21，指示是否对CPUID指令有支持。

64位模式下，EFLAGS被扩展为RFLAGS，高32位是保留的，其他跟EFLAGS一样

4、EIP

不能直接改变，只能通过跳转指令改变，不能直接访问，只能通过call之后查看返回的堆栈中的地址。

指令预取

RIP，使用64位偏移，RIP-relative addressing技术，在下一条指令的RIP中添加位移来确定有效地址



# 操作数大小和地址大小属性

在段描述符中有个D位，如果置位则使用32位的操作数和地址数属性，否则，16bit，被用在实模式，虚拟8086模式以及SMM，默认的通常为16



64位模式下

默认地址size是64位，而默认操作数size是32位，



# 操作数

Base+Index*Scale+Displacement

Index通常是一个寄存器内的值，除了ESP寄存器

如果不指定Base，则认为是DS段，否则如果是ESP或者EBP作为base，则默认为SS段



64位模式下

同样是这样的，但是，记住那四个段寄存器通常被认为是0，所以需要用FS和GS去指定高于4G的内存地址

额外的，可以用RIP+偏移，这是64位模式下的特有的寻址方式，当然这我表示理解。



## IO port 空间

包括65535个8bit的端口



## 对齐

没有对齐需求，但是通常建议对齐，部分4字节的指令，还会引起保护性异常



# 数据类型

## int数据类型（各种int类型）

## 指针数据类型

在非64位的模式下，包括两种指针：near pointer和far pointer

far pointer不仅包括了偏移，还包括了段



64位模式下，near pointer是64bits的，far pointer包括三种模式，16位的段选择子，如果操作数是32bit的就是16bit偏移

16位的段选择子，32bit offset（32位操作数）

16位段选择子，64bit offset（64位操作数）



## string类型

包括bit string和byte string，两种，都大概2^32-1个



## 64bit和128bitSIMD数据类型打包



## packed BCD



## 实数类型

舍入控制字段

包括2bit的RC（rounding control）

x87 FPU控制寄存器的bit10和bit11

MXCSR寄存器的bit13和14

前者控制x87 FPU，而后者控制SIMD比如SSE下面的行为

有些SSE指令可以自动截断成为整数



# 浮点例外概览

无效运算，除以0以及异常操作数是计算前的例外，而数值下溢，数值溢出和精度异常是计算后的异常

每一个都会有相应的标志位和掩码位，

如果发生，并且掩码位也设置了，那么生成预定义的结果，允许程序不受干扰的运行，把该位清除掉，则调用异常处理程序。

默认情况下掩码位置位，可以取消对特定浮点异常的屏蔽。

IA-32位中，在x87fpu状态字和控制字中，状态字0-5位标志位，控制位0-5位掩码位。

MXCSR，0-5位标志位，7-12位掩码位

## 一些关于引起浮点异常的条件



## 浮点异常的优先级

如果多个异常发生，可能会只处理高优先级异常，比如两个异常都屏蔽了，处理器可能仅仅处理高优先级的异常，返回该异常的屏蔽后的结果。

1、无效操作

包括x87中堆栈下溢->x87中堆栈溢出->不支持的格式的操作数->SNaN操作数

2、QNaN操作数

3、上面未提及的其他任何无效运算异常或者被0除异常

4、非正规操作数异常

5、数值上溢、下溢异常

6、不精确结果异常





# 5、指令集概述（4忘了在哪里分了）

分为几组指令集

先是列出了不同处理器支持的指令集的种类

然后每个group分别列举了所有的指令和大概的作用



# 6、call，interrupt和exception

call

除了正常的call和ret，还有enter和leave



procedure linking information



64位模式下的栈行为

SS段寄存器的基址被认为是0，base，limit，和attribute都忽略，SS的DPL一直都等于CPL，

一些指令，比如LDS，POP ES则无效

然后指针会自动64位对齐



near call

压入EIP，load目标地址偏移，开始执行

near return

pop栈顶到EIP

如果RET命令有带个n，同样按照这个弹出



far call

压入CS，压入EIP，载入选择子，载入偏移，开始执行

far return

将栈顶压入EIP

再出栈一个入CS寄存器

带n的同样



参数传递

通过寄存器，通过参数列表（也就是通过传递指向目标数据的指针），或者通过stack



pusha，压入EAX，ECX，EDX，EBX, ESP,EBP,ESI,EDI，popa也一样，（除了ESP寄存器）

call到别的特权级

通过gate



call到别的特权级的情况

临时保存SS，ESP，CS，EIP

载入新的SS和ESP，切换到新的堆栈

将临时保存的旧的堆栈指针保存到新的堆栈上面去

参数拷贝，门描述符会指定传参数量

将CS和EIP也拷贝过去

载入新的code段，执行



64位模式下的branch

near branch重定义

64位的call-gate描述符，用于far call

在64位模式下，near branch被强制为64bit

当使用调用门时，相对于目标地址的偏移，是从调用门那边获得的。而指令中的则忽略

64位模式将32位调用门描述符进行了扩展以支持64位偏移。



由于立即数最多只有32位，所以指定完整的64位RIP的方法是使用间接分支，因此，直接远分支就没了



64位模式下也有特有的SYSENTER和SYSEXIT的扩展：SYSCALL和SYSRET



## 中断和异常

中断是一个由于IO设备导致的异步事件

异常是一个同步事件，由于预定义的问题导致的条件。包括三类 faults，traps和aborts

处理器将这两者等同对待。

通过IDT表

IA32定义了18种预定义的中断和异常以及224种用户定义的异常，每个中断异常定义一个数字，最终一个中断向量表。

0-8，10-14，16-19都是预定义好的，中断异常，32-255则是软件定义的。包括软中断和硬中断。

包括中断门和陷入门

包括访问权限信息，段选择子，偏移

中断门和陷入门的区别在于，使用中断门会清理IF标志位。

具体在这里每个系统保留的中断有个表

对于堆栈切换，如果跳转目标优先级相同，那么使用当前栈，如果跳转到了某个更高优先级的，那么切换到对应的stack

如果堆栈没有切换，那么做如下的动作：

1、将当前的EFLAGS，CS和EIP压栈

2、压入error code

3、将调用门的段选择子和EIP都压入CS和EIP

4、如果是一个中断门，清理EFLAGS的IF位

5、开始执行中断例程



如果发生切换，

1、保存SS，ESP，EFLAGS，CS和EIP

2、从TSS中，载入新的stack pointer和新stack到SS和ESP并且切换栈

3、将临时保存的SS，ESP，EFLAGS，CS和EIP都压栈到新的栈中

4、压入error code

5、将调用门的段选择子和EIP都压入CS和EIP

6、如果是一个中断门，清理EFLAGS的IF位

7、开始执行中断例程



返回是这样的，使用IRET命令

在同一个特权级的情况下，

1、恢复CS和EIP寄存器

2、恢复EFLAGS

3、退栈

4、退出执行

在不同特权级

1、检查特权级

2、恢复CS和EIP

3、恢复EFLAGS

4、恢复SS和ESP并切换堆栈。

5、恢复执行



中断例程可以在一个独立的task中执行，从而导致一个task的切换，通过一个**task 门描述符**。（具体详见后面第三章）



实地址模式的中断处理

同样处理器会做一些保存EFLAGS，EIP，CS以及一个error code



int n，INTO，int 3 BOUND指令

int n使用某个中断向量

INTO，考虑#OF的时候的中断例程，不过正常情况下OF并不会直接导致中断异常。所以要么直接执行INTO（但是仍然会检测标志位），要么检测OF位置位并执行int 4



int 3直接调用BP（break pointer）

BOUND则是相当于int 5，同样的，处理器不会显式的进行边界检查



浮点异常

x87 FPU异常会报错MF

SSE系列会报错XM



64位情况下的中断异常行为

所有的handlers都是64位的

中断栈都是64bit对齐的

**无论是否切换栈，都会压入SS：RSP，**（32位模式下只有CPL发生变化才切换）

IRET行为相应的发生变化

新的中断栈切换行为，

栈帧的对齐也不同



## ENTER和LEAVE

大概的作用就是说，这个有利于函数调用的栈帧的处理。

ENTER有两个变量，一个是压栈数量，多少内存空间，一个是嵌套深度。

对于嵌套深度，有0和非0两种形式，0的表示不嵌套，但是非0的情况，需要不断地压入之前的EBP的嵌套深度。

对于某些语言来说，需要去查找调用他的函数栈中的一些变量，或者更高级别的，因此需要将之前调用他的栈帧的指针全都压进去，但是不在调用链上面的函数过程调用中的变量则是无法访问的，因此，这个ENTER的嵌套深度就是这么用的。

在此虽然每次调用都需要把之前的嵌套的EBP都压入，但是这种方案相比于某些算法中，需要不断地回溯这些内容相比，只需要O（1）的成本即可，更为优秀



LEAVE指令

没有任何的操作数，



# 7、使用General-purpose 指令编程

GP指令集

包括如下一些指令集

数据传输

二进制计算

十六进制计算

逻辑

位移

bit和byte

控制转移

string

IO

enter和leave

flag ctrl

段寄存器

Miscellaneous



## 数据传输

MOV

CMOVcc

MOV指令，一般允许内存和寄存器或者寄存器到寄存器的数据传输，以及立即数到寄存器或者立即数到内存位置，但是不允许内存到内存的传输或者一个段寄存器到另一个段寄存器的传输



XCHG

BSWAP，翻转32位寄存器的字节顺序（用于大小端的转换）








